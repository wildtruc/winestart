#! /bin/bash

# #License:
#   This program is free software; you can redistribute it and/or
#   modify it under the terms of the GNU Lesser General Public
#   License as published by the Free Software Foundation; either
#   version 2.1 of the License, or (at your option) any later
#   version.
#
#   This program is distributed in the hope that it will be useful,
#   but WITHOUT ANY WARRANTY; without even the implied warranty of
#   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#   GNU Lesser General Public License for more details.
#
#   You should have received a copy of the GNU Lesser General Public
#   License along with this program.  If not, see
#   <https://www.gnu.org/licenses/>.
#
## You can redistribute it as you wish : GPL v3
## author : wildtruc@noneltd.net

#PATH=$PATH
colors(){
if [[ -s $HOME/.winestarter/color.conf ]]; then
 . $HOME/.winestarter/color.conf
fi
vb='<span color="'$main'" weight="bold" font="'$font0' '$size0'">'
vn='<span color="'$main'" weight="normal" font="'$font0' '$size0'">'
rb='<span color="'$warn'" weight="bold" font="'$font0' '$size0'">'
gb='<span color="'$freeze'" weight="bold" font="'$font0' '$size0'">'
bf='<span color="'$main'" weight="bold" font="'$font1' '$size1'">'
brf='<span color="'$warn'" weight="bold" font="'$font1' '$size1'">'
#bf='<span color="'$main'" weight="bold" font="'$font' '$(($size+4))'">'
#brf='<span color="'$warn'" weight="bold" font="'$font' '$(($size+4))'">'
nf='<span weight="bold" font="'$font0' '$size0'">'
vz='<span color=\"'$main'\" weight=\"bold\" font=\"'$size0'\">'
end='</span>'
## Script colours Vars.
#t='\e[0;39m'	#default terminal colour
#r='\e[1;31m'	#red
g_notif='\e[1;31m'	#green
c_notif='\e[1;32m'	#cyan
#j='\e[1;33m'	#yellow
i_notif='\e[40m\e[1m\e[37m''\e[1;31m'
e_notif='\e[0;39m'
}
icons_set(){
	png_stock=$HOME/.winestarter/png/defaults
	## window bar icon
	img_desktop=$png_stock/'wine48w.png'
	## main window
	img_wine_add=$png_stock/'new_bottle16.png'
	img_wine_mod=$png_stock/'config16.png'
	img_wine_mng=$png_stock/'bottle_manager16.png'
	img_wine_desk_bt=$png_stock/'desktop16.png'
	img_wine_colors=$png_stock/'colors16.png'
	img_wine_restart=$png_stock/'reload.png'
	## tabs
	img_wine_ui=$png_stock/'wine-wine48.png'
	img_wine_cfg1=$png_stock/'wine-winecfg48.png'
	img_wine_cfg2=$png_stock/'wine-msiexec48.png'
	img_tricks=$png_stock/'wine-winetricks48.png'
	img_reged=$png_stock/'wine-winefile48.png'
	img_nv_cm=$png_stock/'nvidia48.png'
	img_nv_ext=$png_stock/'graphic_set48.png'
	img_xrandr=$png_stock/'display48.png'
	img_opti=$png_stock/'optimus48.png'
	## buttons
	img_tricks_bt=$png_stock/'wine16w.png'
	img_reg_bt=$png_stock/'reg_manager16.png'
	img_ctrlpanel_bt=$png_stock/'control_panel16.png'
	## buttons other
	img_winepol_bt=$png_stock/'playonlinux16.png'
	img_winedis_bt=$png_stock/'wine16r.png'
	img_install=$png_stock/'wine-install48.png'
	## popups
	img_bottle_mng=$png_stock/'bottle_manager48.png'
	img_wine_desktop=$png_stock/'colors48.png'
	img_wine_reload=$png_stock/'reload48.png'
	img_wine_opts=$png_stock/'bottle_manager48.png'
	
	## others
	img_wine_desk_ui=$img_desktop
	img_wine_final=$png_stock/'good_day.png'
}
main_code(){
		default_win_design(){
		[[ $code_tag = 0 ]]|| echo -e "$i_notif\n@@@@ default_win_design @@@@\n$e_notif"
		## reset IFS to include white space
		ifs=$IFS
		IFS=$(echo -ne "\n\b")
		## reset field values
		unset field_list chk_list
		## common sets values are represented under this form:
		## base form : 
		## 1/ input var data (and extended data for combo);
		## 2/ input var name;
		## 3/ tab title (for fn_create_prefix);
		## 4/ field message and information;
		## 5/ field class (CHK,LBL,CB,etc); 
		## 6/ function name (for fn_create_prefix and tab creation);
		## 7/ section tab left side image 
		## >> "TRUE;\2;\3;\4;\5;\6;\7"
		## and catch by the following regex:
		regex_0='^0;(.*;CHK;.*)'
		regex_1='^1;(.*;CHK;.*)'
		regex='(.*);(.*);(.*);[ ]?(.*);([A-Z]{0,4});(.*);(.*)'
		## convert CHK numeric values to TRUE/FALSE
		basic_sets=$(echo "$basic_sets" | sed -E -n "s/$regex_0/FALSE;\1/i;p"| \
		sed -E -n "s/$regex_1/TRUE;\1/i;p")
		
		## fields and corresponding values are then all parsed at the same time and displayed faster.
		field_list=$(echo "$basic_sets" | sed -E -n "s/$regex/--field=\4:\5/p")
		chk_list=$(echo "$basic_sets"| sed -E -n "s/$regex/\1/p" | \
		sed -E -n "s/^([0-9],[0-9],[0-9].*)$/\1,unset/i;p")

		# sortie : ';;TRUE;TRUE;FALSE;TRUE;TRUE;;;FALSE;FALSE;;;TRUE;FALSE;;;;FALSE;'
		# origin regex form: regex='(.*);(.*);(.*);[ ]?(.*);([A-Z]{2,4});(.*);(.*)'
		# corresponding to : "TRUE;\2;\3;\4;\5;\6;\7"
		## extract basic_sets data without labeled line and get exploitable datas only.
		from_basic=$(echo "$basic_sets"|	 egrep -v 'LBL'| sed -E -n "s/$regex/\1;\2;\3;\6;\7/p")

		# ne pas tenir compte des labels
		if [ $win_type = 0 ]; then
			def_win=$($yad_bin --width=$w_width --title "$w_title" --image=$img_wine_ui \
			--window-icon=$img_desktop --form --separator=';' --item-separator="$item_sep" $borders \
			--align=left --text "$bf$w_text$end" $(echo "$field_list") $(echo "$chk_list") )
			if [ $? = 1 ]; then exit 0; fi
			from_output=$(echo "$def_win"| sed -n "s/;/\n/g;p"| cat -b| awk 'NF'| \
			sed -E -n "s/^.*\ ([0-9]{1,3})\t(.*$)/\1#\2/;s/TRUE/1/g;s/FALSE/0/g;p")
		fi
		if [ $win_type = 1 ]; then
			## fields and corresponding values are then all parsed at the same time and displayed faster.
			field_list=( $(echo "$basic_sets" | sed -E -n "s/$regex/--field=\4:\5/p") )
			chk_list=( $(echo "$basic_sets"| sed -E -n "s/$regex/\1/p" | \
			sed -E -n "s/^([0-9],[0-9],[0-9].*)$/\1,unset/i;p") )
		
		
			## extract basic_sets data without labeled line and get exploitable datas only. 
			echo "$basic_sets"| egrep -v "LBL|FBTN"| sed -E -n "s/$regex/\1;\2;\3;\6;\7/p" > $temp_a
			[[ $code_tag = 0 ]]|| echo -e "$g_notif >>>> CHECK ME$e_notif"

			w_width=$((594+$scale))
			$yad_bin --width=$w_width $t_plug $t_rank $t_icon --text="$w_text" \
			$extend_height $extend_pol --form --separator=';' --item-separator="$item_sep" $focus \
			"${field_list[@]}" "${chk_list[@]}" > $temp_b &
		fi
#		if [ $win_type = 2 ]; then
#			"${field_list[@]}" "${chk_list[@]}"
#		fi

		## restore IFS to previous state
		IFS=$ifs
		## from here, yad window is waiting for validation to go to next process.
		[[ $code_tag = 0 ]]|| echo -e "$g_notif\n>>>> $temp_a\n>>>> $(cat $temp_a)$e_notif"
		[[ $code_tag = 0 ]]|| echo -e "$g_notif\n>>>> $temp_b\n>>>> $(cat $temp_b)$e_notif"
	}
		default_tab_design(){
		[[ $code_tag = 0 ]]|| echo -e "$i_notif\n@@@@ default_tab_design @@@@\n$e_notif"
		wait_message='CREATE UI'
		fn_plz_wait &
		WAIT_UI_1=$(ps -A | grep "yad" | awk '{print $1}'| sed -n '1p')
#		n_cfg=1
		_num_tab=1 
		
		## This, represent only window tab order and making.
		## compare input and output datas.
		## redefine regex for new output form.
		## output data to be treated are represented under this form : 
		## 1/ output var data;
		## 2/ input>output var name;
		## 3/ tab title (for fn_create_prefix);
		## 6/ function name (for fn_create_prefix and tab creation);
		## 7/ section tab left side image
		regex='(.*);(.*);(.*);(.*);(.*)'
		### valeur spÃ©cifiques
		for _out_var in ${from_output}; do
			_line=$(printf "$_out_var"| cut -d'#' -f1)
			_val=$(printf "$_out_var"| cut -d'#' -f2)
			if [[ $_val =~ TRUE|FALSE ]]; then
				if [[ $_val == 'TRUE' ]]; then _val=1; else _val=0; fi
			fi
			if [ $(printf "$_line"| grep -c .) -gt 0 ]; then
				## extract variable value by emulating cut.
				_out_var=$(echo "$from_basic"| sed -n $_line\p| sed -E -n "s/$regex/\2/p" ) #/2
				if [ $_val -gt 0 ]; then
					## define if the basic_sets come from initial tab creation or not.
					if [ $(echo "$from_basic"| sed -n $_line\p| \
					sed -E -n "s/$regex/\3/p"| grep -c .) -gt 0 ]; then
						_out_tab=$(echo "$from_basic"| sed -n $_line\p| sed -E -n "s/$regex/\3/p" ) #/3
						_out_fun=$(echo "$from_basic"| sed -n $_line\p| sed -E -n "s/$regex/\4/p" ) #/4
						_out_img=$(echo "$from_basic"| sed -n $_line\p| sed -E -n "s/$regex/\5/p" ) #/5
						## prepare tab values per section and add them to tab list.
						tab_set+=("$_num_tab;$_out_var;$_out_tab;$_out_fun;$_out_img")
						## increment by 1 at each loop.
						_num_tab=$[ $_num_tab+1 ]
					fi
				else
					_val=0
				fi
			fi
			## independently of any previous filters, sent output var to local script environment.	
			if [[ $_out_var == _extended ]]; then
				export $_out_var=$_val 
			else
				local $_out_var=$_val
			fi
			[[ $code_tag = 0 ]]|| echo -e "$g_notif\n>>>> tab_set \n>>>> ${tab_set[@]}$e_notif"
		done
		
	}
	default_tab_create(){
		[[ $code_tag = 0 ]]|| echo -e "$i_notif\n@@@@ default_tab_create @@@@\n$e_notif"
		## after each tab lists are defined, analyse them by loop to create corresponding window tabs.
		## cycle between each defined tabs to prepare their temp files 
		for tab_vars in ${tab_set[@]}; do
			## extract all vars from tab_set list.
			t_num=$(printf "$tab_vars"| cut -d';' -f1)
			t_var=$(printf "$tab_vars"| cut -d';' -f2)
			t_name=$(printf "$tab_vars"| cut -d';' -f3)
			t_fn_op=$(printf "$tab_vars"| cut -d';' -f4)
			t_img=$(printf "$tab_vars"| cut -d';' -f5)			
			## if tab number is not null create corresponding temp files and fields data.
			if [ $t_num -gt 0 ]; then 
				temp_a=$(mktemp --tmpdir tab$t_num.a.XXXXXXXX)
				temp_b=$(mktemp --tmpdir tab$t_num.b.XXXXXXXX)
				tmp_key_a=$(printf "$temp_a"|sed -n "s|^.*\.||p")
				tmp_key_b=$(printf "$temp_b"|sed -n "s|^.*\.||p")
				t_plug="--plug=$key"
				t_rank="--tabnum=$t_num"
				t_icon="--image=$t_img"
				t_name=$(printf "$t_name"| tr '*' ' ')
				t_display+=("--tab=$t_name")
				
				t_val=1
			else
				t_val=0
			fi
			## add/create window tab data to be listed in extract_tmp_settings section.
			tab_temp+=("$t_var;$t_val;$t_name;$temp_a;$temp_b;$tmp_key_a;$tmp_key_b")
			[[ $code_tag = 0 ]]|| echo -e "$g_notif\n>>>> tab temp\n>>>> ${tab_temp[@]}$e_notif"
			## if specific function is associated, execute it to get datas.
			## each time a tab is assigned, start associated function to load tab content in temp files.
			if [ $t_num -gt 0 ]; then ${t_fn_op}; fi ## <<<< SOOOO, IMPORTANT
			
			
		done
		if [ $win_type = 1 ]; then
#		## give more time to winetricks
#		while [[ $(pgrep 'winetricks') ]]; do
#			sleep 1
#		done
		kill $WAIT_UI_1
			w_width=$((800+$scale))
			$yad_bin --width=$w_width --title "$w_title" --window-icon=$img_wine_desk_ui --borders=15 \
			$main_height $main_scroll --notebook --key=$key --tab-pos=right --tab-border=2 \
			--text="$main_tab_text" "${t_display[@]}"
			e_exit=$?
			## yad tabed window is displayed here.
			if [ $t_var == _resume ]; then
#				if [ $e_exit -ge 0 ]; then exit 0; fi
				if [ $e_exit -gt 0 ]; then exit 0; else bash $bash_opt "$res_action"; fi
			else
				if [ $e_exit = 1 ]; then
					exit 0
				else
					if [ $t_var == _wfirst ]; then
						fn_wine_basic_feed
					else
						extract_tmp_settings
					fi
				fi
			fi
		fi

	}
	## from here, this meaning tab data are modified/set and validation button has been pressed.
	extract_tmp_settings(){
		[[ $code_tag = 0 ]]|| echo -e "$i_notif\n@@@@ extract_tmp_settings @@@@\n$e_notif"
		wait_message='WORKING'
		fn_plz_wait &
		WAIT_UI_2=$(ps -A | grep "yad" | awk '{print $1}'| sed -n '1p')
		[[ $code_tag = 0 ]]|| echo -e "$g_notif\n>>>> tab temp resume :\n${tab_temp[@]}$e_notif"
		for sets in "${tab_temp[@]}"; do
			unset _out_conf_sets
			_out_var=$(printf "$sets"| cut -d';' -f1)
			_out_var_val=$(printf "$sets"| cut -d';' -f2)
			_out_tmp_a=$(printf "$sets"| cut -d';' -f4)
			_out_tmp_b=$(printf "$sets"| cut -d';' -f5)
			fn_reconf=(reconf$_out_var)
			
			from_basic=$(cat $_out_tmp_a)
			## convert yad tab output datas to usable data for basic>output diff.
			
			## filter per conf type first. Output analysis is not necessary the same for all.
			if [ $_out_var == _tricks ]; then
				from_output=$(cat $_out_tmp_b| sed -n "s/;/\n/g;p"| cat -b | grep -v "FALSE" | awk 'NF'| \
				sed -E -n "s/^.*\ ([0-9]{1,3})\t(.*$)/\1#\2/;s/TRUE/1/g;p")
			else
				from_output=$(cat $_out_tmp_b| sed -n "s/;/\n/g;p"| cat -b | awk 'NF'| \
				sed -E -n "s/^.*\ ([0-9]{1,3})\t(.*$)/\1#\2/;s/TRUE/1/g;s/FALSE/0/g;p")
			fi
			regex='(.*);(.*);(.*);(.*);(.*)'
			ifs=$IFS
			IFS=$(echo -ne "\n\b")
			for _conf_var in ${from_output}; do
				_line=$(printf "$_conf_var"| cut -d'#' -f1)
				_val=$(printf "$_conf_var"| cut -d'#' -f2)
					_out_line=$(echo "$from_basic"| sed -n $_line\p| sed -E -n "s/$regex/\2/p" )
				if [[ $_out_line ]]; then
					## send all output datas in a single list that be used at the beginning of reconf part. 
					_out_conf_sets+=($_out_line=$_val)
				fi				
			done
			
			[[ $code_tag = 0 ]]|| echo -e "$g_notif\n>>>> $_out_var vars list:\n${_out_conf_sets[@]}\n$e_notif"
			
			## define the config write method.
			## If config file exist choose between 2 method:
			if [ $from_config = 1 ]; then
			## section already exist:
				_fn_exist=$(cat $config_file| grep -wc "$_out_var")
				## start the reconf section.
				[[ $code_tag = 0 ]]|| echo -e "$g_notif >>>>> reconf section for $_out_var$e_notif"
				${fn_reconf}
				## If section exist, enter changes then insert it in tempory conf file.
				if [ $_fn_exist -gt 0 ]; then
				## define the beginning and the end of section text.
					[[ $code_tag = 0 ]]|| echo -e "$g_notif >>>>> write temp file for $_out_var $e_notif"
					_first=$(echo "$_section"| sed -n '1p'|sed -n "s|/|\\\/|g;p" )
					_last=$(echo "$_section"| sed -n '$p')
					## suppress previous section text from the conf file and replace it with section keyword
					## in temporary conf file. FIXME ?
					cat $TEMP_conf| sed -n "/$_first/,/^$_last/{;s/.*/$_out_var/};p"| uniq > $TEMP_edit
					## Then replace the keyword by the modified section text.
					perl -ni -pe "s|^$_out_var|$(echo "$_section")|i" $TEMP_edit
					mv -f $TEMP_edit $TEMP_conf
				else
				## section doesn't exist: Then, just add at the end of the temporary conf file.
					echo -e "$_section\n" >> $TEMP_conf
				fi
			else
			## For new fresh conf, just write by pushing section conf text at the end of the file
				[[ $code_tag = 0 ]]|| echo -e "$g_notif >>>>> new fresh section for $_out_var$e_notif"
				${fn_reconf}
				echo -e "$_section\n" >> $TEMP_conf
			fi
			sleep 1
			IFS=$ifs
		done
		## if conf file is new one, define the conf name before copying.
		if [ $from_config = 0 ]; then
			config_file=$(printf "$bottle_prefix"| sed -n "s/^\.//p")'.conf'
			cp -f -T $TEMP_conf $HOME/.winestarter/configs/$config_file
		else
			cp -f -T $TEMP_conf $config_file
		fi
		kill $WAIT_UI_2
		end_game_display
		if [ $? -ge 0 ]; then exit 0; fi
#		if [ $e_exit -gt 0 ]; then exit 0; else bash $bash_opt "$res_action"; fi
	}
	## wait patiently window
	fn_plz_wait(){
		$yad_bin --width=200 --title "Please wait..." --text-align=center --no-buttons $on_top \
		--window-icon=$img_wine_ui --progress --pulsate --auto-close \
		--text="$vb\\$wait_message$end" --progress-text=""
	}
	## end process window and tab
	end_game_display(){
		unset  tab_set tab_temp cfg_set t_display form_win 
		# launch default start window
		conf_target=$(printf "$bottle_prefix"|  sed -n "s/^.*[\/.\|.]\(\w*[Aa-Zz]\.\w*[Aa-Zz]*\)/\1/g;p")
		w_title="Wine Starter"
		main_tab_text="$bf Configuration applied to$end $brf$conf_target$end"
		tab_set=("1;_resume;Resume;fn_end_game_1;$img_wine_final")
#		"2;_resume;Warnings;fn_end_game_2;$img_wine_desk_ui")
		# window style and function
		win_type=1
		focus='--focus-field=2'
		# create main window variables
		default_tab_create
	}
	fn_end_game_1(){
		## --field="$vb New Wine prefix $end"#$img_wine_add
		## "Create and config a fresh new Wine prefix":FBTN "$main_cmd_0" \
		if [ $code_tag -gt 0 ]; then
#			_dev_dir=$(echo -e "$0"| sed -En "s|^(.*)/(winestarter_conf)$|\1|g;p"
			res_action="~/Devel/WINE/winestart/winestarter $conf_target.conf"
		else
			res_action="winestarter $conf_target.conf"
		fi
		w_text="$bf\All change are saved to the prefix configuration.$end\\n
$vb\\You can launch the script now by clicking validation button or from a terminal window with the command line below:$end\\n
winetstarter $conf_target.conf\\n"
		w_text1="\\n$nf\\Note$end$vn : Desktop file entry doesn't exist at this step, but will available after the prefix's program installation.$end"
		w_text2="$nf\\Special warning$end$vn : When using this tool, you can occur window crash or freeze. This is a Yad issue that will be hopefuly fix in a near futur.$end"
#		basic_sets="'';;;;LBL;;
#$res_action;;;$res_launch;FBTN;;
#'';;;;LBL;;
#'';;;$w_res_0;LBL;;"
		basic_sets="'';;;;LBL;;
'';;;$w_text1;LBL;;
'';;;$w_text2;LBL;;"
		item_sep='!'
		# start form display
		win_type=1
		default_win_design
		# create main window variables
#		if [ $? -gt 0 ]; then exit 0; else bash $bash_opt "$res_action"; fi
	}
#	fn_end_game_2(){
#		w_text="Blabla"
#		w_res_1="Blobloblo"
#		basic_sets="'';;;$w_res_1;LBL;;
#'';;;;LBL;;"
#		# start form display
#		win_type=1
#		default_win_design
#		# create main window variables
#	}
	reconf_wine(){		
		# "user_prefix bottle_prefix game_path game_dir game_exe use_winepath wine_path wine_ver"
		[[ $code_tag = 0 ]]|| echo -e "$g_notif\n##### reconf_wine $e_notif"
		## send output datas to local script env.
		local ${_out_conf_sets[@]}
		## rewrite specifics variables for correct display and use.
		for _list in ${_out_conf_sets[@]}; do
			_var=$(printf "$_list"|cut -d'=' -f1)
			_val=$(printf "$_list"|cut -d'=' -f2)
			eval _listed='$'$_var
			if [[ $_listed =~ ^$HOME[\/]?$ ]]; then
				if [[ $_var != user_prefix ]]; then local $_var=''; fi
			fi
			case $_var in
				'bottle_prefix') bottle_prefix=$(printf "$bottle_prefix"| sed -n "s|^.*/||g;p") ;;
				'game_path')
					game_key=$(printf "$game_path"| sed -n "s|^.*/||g;p")
					if [[ $game_key =~ $USER ]]; then game_key=''; fi
					if [[ $game_path == $HOME ]]; then game_path=''; fi
				;;
				'game_dir')
					if [[ $game_key != '' ]]; then
						if [ $(printf "$game_dir"| grep -c "$game_key") -gt 0 ]; then
							game_dir=$(printf "$game_dir"| \
							sed -n "s|^.*\w*$game_key\(.*$\)|$game_key\1|p")
						fi
					else
						if [ $(printf "$game_dir"| grep -c "Program\ Files") -gt 0 ]; then
							game_dir=$(printf "$game_dir"| \
							sed -n "s|^.*Files$elf_ext/\(.*\)$|\1|p")
						else
							game_dir=$(printf "$game_dir"| sed -n "s|^.*drive_c/\(.*\)$|\1|g;p")
						fi
					fi
				;;
				'game_exe')
					if [[ $game_exe =~ ^.*\.(exe|EXE)$ ]]; then
						game_exe=$(printf "$game_exe"| \
						sed -En "s|^.*($game_dir)/(.*)([exe|EXE]?)$|\2\3|p")
					else
						game_exe=''
					fi
				;;
			esac
		done
		## Extended appears in tab only if extended option check box is setted.
		if [ $_extended = 1 ]; then
			if ! [[ -e $user_prefix/$bottle_prefix/options.log ]]; then
				touch $user_prefix/$bottle_prefix/options.log
			fi
			for opts in ${reconf_list[@]}; do
				_opt_var=$(printf "$opts"| cut -d';' -f3)
				_opt_id=$(printf "$opts"| cut -d';' -f2)
				eval _var='$'$_opt_var
				if [ $_var -gt 0 ]; then
					_args+=("-$_opt_id")
				fi
			done
			if [ $wine_arg_msc ]; then
				if [[ $wine_arg_msc != unset ]]; then
					## add editable option to args list.
					_args+=("$wine_arg_msc")
					##* At the point wine args options list is complete and ready to be wrote.
					##* Next process is for changes and write of bottle options.log.
					## Check if a diff appears between present options and bottle options.log:
					## Make of wine_arg_msc a usable list.
					msc_arg_list=("$wine_arg_msc")
					## Control last modification EPOC time.
					if [[ -s $option_log ]]; then
						_option_log_mod=$(stat -c %Y $option_log )
					else
						_option_log_mod=$(date +%s)
					fi
					## compare previous EPOC check and new EPOC check.
					if [ $_option_log_mod -gt $_option_log_pre ]; then
						## first, check if elements of wine_arg_msc are not in bottle options menu.
						for _mod_line in ${reconf_list[@]}; do
							_mod_id=$(printf "$_mod_line"| cut -d";" -f2)
								## if option in bottle options menu list is not in wine_arg_msc,
								## add it to wine_opts value for config file write.
								if [ $(echo "${msc_arg_list[*]}"| grep -c "$_mod_id") -eq 0 ]; then
									msc_arg_list+=("-$_mod_opt")
								fi
						done
					fi
					##* Now, we need to compare and evaluate if wine_arg_msc elements have to be add to 
					##* bottle options.log.
					for _msc_val in ${msc_arg_list[@]}; do
						## create the short tag for wine_arg_msc elements. If element has ponctuation like
						## '_' or '-', remove all words before till leaving one unique word. If not
						## ponctuation is detected, leave as it is.
						if [ $(echo -e "$_msc_val"| egrep -c "[[:punct:]]") -gt 0 ]; then
							_msc_short=$(echo -e "$_msc_val"| sed -nE "s/^.*[[:punct:]](\w*[a-z]$)/\1/p")
						else
							_msc_short="$_msc_val"
						fi
						## remove all options suffix element to create unique ID per element.
						_msc_arg=$(echo -e "$_msc_val"| sed -n "s/^-//p")
						_msc_var=("wine_arg_$_msc_short")
						## if short tag already exist, number it to make a different ID.
						if [[ $(cat $option_log| egrep -c "$_msc_var.*;") -gt 0 && \
						$(cat $option_log| egrep -c "$_msc_arg;$_msc_var.*;") -eq 0 ]]; then
							_msc_short=$_msc_short"_"$msc_n
							_msc_var=("wine_arg_$_msc_short")
							msc_n=$[ $msc_n+1 ]
						fi
						## Final step check if option is not present neither in bottle options.log and
						## bottle menu options list, then write it to bottle options.log with a value of
						## 0 (not in bottle options menu list yet)
						if [ $(cat $option_log| egrep -c "$_msc_arg") -eq 0 ]; then
							if [ $(echo "${reconf_list[@]}"| egrep -c "$_msc_arg") -eq 0 ]; then
								## last number in file insertion tell if option is add to default menu.
								printf "$_msc_short;$_msc_arg;$_msc_var;0\n" >> $option_log
							fi
						fi
					done
				else
				## if global options value return 0 or 'unset' 
					_args+=('')
				fi
				wine_opts="${_args[@]}"
			fi
			## if tother otions need attention, manage them below
		fi
		_wine=1
		if [ $from_config = 0 ]; then newconf_headers; fi
		newconf_wine
	}
	newconf_wine(){
			_section="## Allow extended features for winestarter configurator; off (0), on (1)
_extended=$_extended
## Allow asking for cache memory wipe at winestater boot: off (0), on (1)
## NOTICE: Cache wipe question popup only appear above 60% memory cache used.
cache_wipe=$cache_wipe\n 
## default is user's home.
user_prefix=$user_prefix
## game/appli prefix name
bottle_prefix=\"$bottle_prefix\"
## default system path of the game/appli if not in the chosen Wine prefix
game_path=\"$game_path\"
## Full game dir name in Program Files
game_dir=\"$game_dir\"
game_exe=\"$game_exe\"
## By default Winestarter set full screen Wine windowed that improve game stability.
## Set windowed mode: false (0), true (1, default)
windowed=$windowed
## set if the app is portable or to be installed in C: drive root: no (0), yes (1).
app_portable=$app_portable
## if classic wine command fail, execute .exe inside the directory
special_cmd=$special_cmd
## wine can use \"start\" command to launch apps or installer from absolute path
## useful on old or recalcitrant buggy app.
start_cmd=$start_cmd
## set a 64 bits bottle: false (0), true (1)
wine_elf=$wine_elf

## WineDbg speicals:
## In some case WineDbg crash dialog popups even if finally the managed app launch correctly.
## This option prevent the crash dialog to popup on working apps start: on (1), off (0)
dbg_dialog=$dbg_dialog
## This option let application handles exceptions by itself, then WneDbg only catches exceptions that
## are not handled by the app and could make debbuging a bit easier: on (1), off (0)
dbg_handle=$dbg_handle
## In some apps, it's possible to send extended options at the end of command line.
## It can be some extra DLLs, game map, etc. Add them here.
wine_opts=\"$wine_opts\"

## to lauch winecfg at first launch
w_config=$w_config
## Do not remove or edit below except if you don't use winestarter configurator.
_wine=$_wine"
	}
	newconf_headers(){
		## insert script headers at first config step
		conf_headers="#! /bin/bash\n
##  Winestarter Configurator
##  Fri Feb  10 14:00:00 2017
##  Copyright  2017  PirateProd
##  <wildtruc@noneltd.net>
##  This program is free software; you can redistribute it and/or
##  modify it under the terms of the GNU Lesser General Public
##  License as published by the Free Software Foundation; either
##  version 2.1 of the License, or (at your option) any later version.
##
##  This program is distributed in the hope that it will be useful,
##  but WITHOUT ANY WARRANTY; without even the implied warranty of
##  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
##  Lesser General Public License for more details.
##
##  You should have received a copy of the GNU Lesser General Public
##  License along with main.c;if not, write to the Free Software
##  Foundation, Inc., 51 Franklin Street, Fifth Floor Boston, MA 02110-1301,  USA

## comments with '##' are user help comments
## comments with '#' are unset feature
"
		[[ $code_tag = 0 ]]|| echo -e "$conf_headers" > $TEMP_conf
	}
	reconf_wbin(){
		[[ $code_tag = 0 ]]|| echo -e "$g_notif\n##### reconf_wbin $e_notif"
		## send output datas to local script env.
		local ${_out_conf_sets[@]}
		## take care that wine_path is not HOME prefix. user_prefix/winebin dir is default, but could
		## different as user want. 
		for _list in ${_out_conf_sets[@]}; do
			_var=$(printf "$_list"|cut -d'=' -f1)
			_val=$(printf "$_list"|cut -d'=' -f2)
			case $_var in
				'use_winepath')
					if ! [[ $(find /usr/{bin,local/bin} -name wine) ]]; then
						use_winepath=1
					fi
				;;
				'wine_path')
					_def_val=.winebin
					if [[ $_val != $HOME || $_val != $user_prefix/$_def_val ]]; then
						_def_val=$(printf "$_val"| sed -n "s/^.*\///p")
						_prefix=$(printf "$_val"| sed -E -n "s/^(.*)\/(.*)$/\1/p")
						wine_path=$_prefix/$_def_val
					else
						wine_path=$user_prefix/$_def_val
					fi
				;;
				_hq_stb0|_hq_stg0|_hq_stg1|_hq_stg2|_hq_dev0| _pol_pkg )
					if [[ $_val != 'unset' ]]; then
						if [[ $_var == _pol_pkg ]]; then wine_ver=$_pol_pkg; wine_pack=0 ;fi
						if [[ $_var == _hq_dev0 ]]; then wine_ver=$_hq_dev0; wine_pack=1 ;fi
						if [[ $_var == _hq_stb0 ]]; then wine_ver=$_hq_stb0; wine_pack=1 ;fi
						if [[ $_var == _hq_stg0 ]]; then wine_ver=$_hq_stg0; wine_pack=1 ;fi
						if [[ $_var == _hq_stg1 ]]; then wine_ver=$_hq_stg1; wine_pack=2 ;fi
						if [[ $_var == _hq_stg2 ]]; then wine_ver=$_hq_stg2; wine_pack=3 ;fi
						wine_ver=$(printf "$wine_ver"| sed -n "s/*$//g;p")
						w_config=1
					fi
				;;
				'wine_ver')
					if [[ $_val =~ $_def_val$ ]]; then
						wine_ver=''
					else
						wine_ver=$(printf "$_val"| sed -n "s|^.*/||g;p")
					fi
				;;
				'w_config')
					if [ $from_config = 1 ]; then
						if [ $w_config -gt 0 ]; then
							sed -ni "s/^\(w_config\)=[0-9]$/\1=$w_config/g;p" $TEMP_conf
						fi
					fi
				;;
			esac
		done
		if [ $use_winepath = 1 ]; then _wbin=1; fi
		newconf_wbin	
	}
	newconf_wbin(){
		_section="## Use a specific Wine path: yes (1), no (0).
use_winepath=$use_winepath
## where is your custom Wine binary, if any
wine_path=\"$wine_path\"
## custom Wine binary name
wine_ver='$wine_ver'
## Which kind of packages do you want to use: (leave empty if already in bin directory)
## PlayOnLinux (0), WineHQ stable/staging/development > 2.4 (1), WineHQ old staging < 2.4 (2),
## Wine third party staging > 3.3 (3)
wine_pack=$wine_pack
## Do not remove or edit below except if you don't use winestarter configurator.
_wbin=$_wbin"
	}
	reconf_install(){
		[[ $code_tag = 0 ]]|| echo -e "$g_notif\n##### reconf_install $e_notif"
		M=0
		local ${_out_conf_sets[@]}
		for _list in ${_out_conf_sets[@]}; do
			_var=$(printf "$_list"|cut -d'=' -f1)
			_val=$(printf "$_list"|cut -d'=' -f2)
			eval _listed='$'$_var
			if [[ $_listed =~ ^$HOME[\/]?$ ]]; then
				local $_var=''
			fi
			case $_var in
				'w_exe_path')
					if [[ $_listed =~ ^.*\.(exe|EXE|msi|MSI)$ ]]; then
						if ! [ -s $config_file ]; then
							w_install_exe=1
						fi
						((M++))
					fi
				;;
				'w_tricks_opts')
					if [ $_listed = 1 ]; then w_tricks_opts='--no-isolate'; else w_tricks_opts=''; fi
				;;
				'w_more_pkgs')
#					if [[ $_listed ]]; then
					if [ $(echo "$_listed"| grep -c "\,") -gt 0 ]; then
						w_more_pkgs=$(echo -e "$_listed"| sed -E -n "s/,/\n/g;p")
						((M++))
					fi
				;;
				'w_install_dir')
					if [[ $w_install_zip ]]; then
						if [[ $(printf "$_listed"| egrep -c "^.*-") -gt 0 ]]; then
							w_install_dir=$(printf "$_listed"| \
							sed -En "s/([[:alnum:]]*)-.*$/\1/;s/^.*\///g;p")
						fi
						((M++))
					else
						w_install_dir=''
					fi
				;;
				'w_download_dir')
					w_download_dir=$XDG_DOWNLOAD_DIR
				;;
			esac
			if [ $M -gt 0 ]; then
				if [[ -s $user_prefix/$bottle_prefix/packages.log ]];then
					check=$(printf "$_listed"| sed -n "s/^.*\///g;p")
					if [ $(cat $user_prefix/$bottle_prefix/packages.log| grep -wc "$check" ) -gt 0 ]; then
						w_install_exe=0
					else
						w_install_exe=1
					fi
				else
					w_install_exe=1
				fi
			fi
		done
#		if [ $M -gt 0 ]; then _install=1; fi
#		_install=1
		if [ $w_install_exe = 1 ]; then _install=1; else _install=0; fi
		newconf_install
	}
	newconf_install(){
		if [[ $w_extra_script == $HOME/ ]]; then w_extra_script=''; fi
		_section="## This option allow to install .exe or .msi through winestarter process.
## It's possible to replace file name path by an internet URL for download it.
w_install_exe=$w_install_exe
## Winetricks options, if any
w_tricks_opts='$w_tricks_opts'
## Full path of the software exe/msi file to install
w_exe_path=\"$w_exe_path\"
## Additional associated dlls or app packages list to install (if any)
w_more_pkgs='$w_more_pkgs'
## In some cases, install is provided by extractible or auto-extractible package
## This option will install them in the provided directory to the Program Files path
w_install_zip=\"$w_install_zip\"
## otherwise, you can specify the install dir from the root C: drive.
w_install_dir=\"$w_install_dir\"
## Download dir is the user default one, you can change it here.
w_download_dir=\"$w_download_dir\"
## user script: You can add here a personal or a community script (updater, logs, etc)
## It will be automaticaly pasted in the installed app directory.
## This is very optional and at your own risk
w_extra_script=\"$w_extra_script\"
## Do not remove or edit below except if you don't use winestarter configurator.
_install=$_install"
	}
	reconf_tricks(){
		[[ $code_tag = 0 ]]|| echo -e "$g_notif\n##### reconf_tricks $e_notif"
		M=0
		local ${_out_conf_sets[@]}
		for _list in ${_out_conf_sets[@]}; do
			_var=$(printf "$_list"|cut -d'=' -f1)
			_val=$(printf "$_list"|cut -d'=' -f2)
			eval _listed='$'$_var
			if [[ $_var =~ (ie8|ie7|ie6) ]]; then _var="$_var wininet winhttp"; fi
			if [[ $_listed = 1 ]]; then
				_tricks_var+=("$_var")
			fi
		done
		w_tricks_list_prev=$w_tricks_list
		if [[ $w_tricks_list_prev == '' ]]; then
			if [ ${#_tricks_var[*]} -gt 0 ]; then
				w_install_tricks=1
			else
				w_install_tricks=0
			fi
		fi
		w_tricks_list=$(echo -e "${_tricks_var[@]}"|tr ' ' ',')
		if [[ $w_tricks_list_prev ]]; then
			for _prev in ${_tricks_var[@]}; do
				if [ $(printf "$w_tricks_list_prev"| grep -c "$_prev") -eq 0 ]; then
					_tricks_var_new+=("$_prev")
				fi
			done
			_tricks_list_new=$(echo -e "${_tricks_var_new[@]}"|tr ' ' ',')
#			w_tricks_list=$(printf "$w_tricks_list_prev"| sed -E -n "s/^(.*)/\1,$_tricks_list_new/p")
			if [ ${#_tricks_var_new[*]} -gt 0 ]; then
				w_tricks_list=$(printf "$w_tricks_list_prev"| sed -E -n "s/^(.*)/\1,$_tricks_list_new/p")
				w_install_tricks=1
			else
				w_tricks_list=$w_tricks_list_prev
				w_install_tricks=0
			fi
		fi
		
		if [ $(printf "$w_tricks_list"| grep -c .) -gt 0 ]; then _tricks=1; else _tricks=0; fi
		newconf_tricks
	}
	newconf_tricks(){
		_section="## (0) first install launch and prefix creation already set, (1) first launch
w_install_tricks=$w_install_tricks
## Winetricks components list
w_tricks_list=\"$w_tricks_list\"
## Do not remove or edit below except if you don't use winestarter configurator.
_tricks=$_tricks"
	}
	reconf_reged(){
		[[ $code_tag = 0 ]]|| echo -e "$g_notif\n##### reconf_reged $e_notif"
		M=0
		R=0
		unset _reged_var
		## extract first here the editable regedit field into a readable list
		user_edit=$(echo "$from_output"| grep "HKEY_CURRENT_USER"| cut -d'#' -f2)
	
		local ${_out_conf_sets[@]}
		for _list in ${_out_conf_sets[@]}; do
			_var=$(printf "$_list"|cut -d'=' -f1)
			_val=$(printf "$_list"|cut -d'=' -f2)
			[[ $code_tag = 0 ]]|| echo -e "$g_notif >>>>> ${_reged_var[*]} $e_notif"
			if ! [[ $_var =~ ^dll*|^mime* ]]; then
				if [[ $_var == user_reg ]]; then
					if [[ $user_reg =~ ^\[.*\]$ ]]; then unset -v user_reg; _val='unset'; fi
				fi
				if [[ $_val != unset ]]; then
					if [[ $_var == csmt ]]; then
						if [[ $_val == enabled ]]; then _val='00000001'; else _val='00000000'; fi
					fi
					if [[ $_val =~ [0-9]{8} ]]; then
						_reged_var+=("\"$_var\"=dword:$_val")
					else
						_reged_var+=("\"$_var\"=\"$_val\"")
					fi
#				else
#					_reged_unset+=($_var)
				fi
			else
				if [ $_extended = 1 ]; then
					if [ $_val != unset ]; then
						case $_var in
							'Selected_Files')
								[[ $code_tag = 0 ]]|| echo -e "$g_notif >>>>> $_var $e_notif"
								selected_files_list=( $(echo "$_val"| sed -n "s/,/\n/g;p") )
								for Files in ${selected_files_list[@]}; do
									if [ $(printf "$local_association"| grep -c .) -gt 0  ]; then
										prev_asso="$local_association,"
										file_ext=$(printf "$Files"| sed -n "s/^.*\.//g;p")
										if [ $(printf "$local_association"| grep -c "$file_ext") -eq 0 ]; then
											mime_type=$(xdg-mime query filetype $Files)
											if [ $(printf "		$mime_type"| grep -c .) -gt 0 ]; then
												## define the the reg mime type elements
												_filetype=$(printf "$Files"|sed -n "s/^.*\.//g;p")
												_doctype=$(printf "$_filetype"|sed -n "s/.*/\U&/p")'file'
												## add them to the resource list
												res_mime=$HOME/.winestarter/resources/mime-type.lst
												if [ $(cat $res_mime |grep -c "_doctype") -eq 0 ]; then
													printf "$_filetype:$_doctype:$mime_type\n" >> $res_mime
												fi
												## add the file extension to the config file type section
													FileType_list+=( "$_filetype" )
											fi
										fi
									else
										FileType_list+=( $(printf "$Files"|sed -n "s/^.*\.//g;p") )
									fi
								done
								_val=$prev_asso$(printf "${FileType_list[*]}"| tr ' ' ',')
							;;
							'mime_preset')
								[[ $code_tag = 0 ]]|| echo -e "$g_notif >>>>> $_var $e_notif"
								mime_preset_list=( "$_val" )
								if [ $(printf "$local_association"| grep -c .) -gt 0  ]; then
									for preset in ${mime_preset_list[@]}; do
										if [ $(printf "$local_association"| grep -c "$preset") -eq 0 ]; then
											mime_preset_add+=("$preset")
										fi
									done
									if [ ${#mime_preset_add[@]} -gt 0 ]; then _sep=','; ((M++)); fi
									prev_asso="$local_association$_sep"
									_val=$prev_asso$(printf "${mime_preset_add[*]}"| tr ' ' ',')
									_val=$prev_asso${mime_preset_add[*]}
								else
									_val=$(echo "$mime_preset"| tr ' ' ','); ((M++))
								fi
								local local_association=$_val
							;;
							'dll_reg_type')
								[[ $code_tag = 0 ]]|| echo -e "$g_notif >>>>> $_var $e_notif"
								if [[ $_val == register ]]; then _reg_class=1; else _reg_class=0; fi; ((R++))
							;;
							'dll_elf_type')
								[[ $code_tag = 0 ]]|| echo -e "$g_notif >>>>> $_var $e_notif"
								if [[ $_val == both ]]; then
									_reg_elf=2
								else
									if [[ $_val == wine32 ]];then _reg_elf=0; else _reg_elf=1; fi
								fi
							;;
							'dll_file_list')
								[[ $code_tag = 0 ]]|| echo -e "$g_notif >>>>> $_var $e_notif"
								if [[ $_val =~ \.(dll|DLL)$ ]]; then
									_dlls_list=$(printf "$_val"| tr ',' '\n')
									for _dlls in ${_dlls_list[@]}; do
										_conf_dlls+=( "$(printf "$_dlls"| sed -n "s/^.*\///g;p")," )
									done
									[[ $code_tag = 0 ]]|| echo -e "$g_notif >>>>> ${_conf_dlls[@]} $e_notif"
									_reg_dlls=$(echo "${_conf_dlls[@]}"| sed -n "s/\ //g;s/\,$//p")
								fi
							;;
						esac
						if [ $R -gt 0 ]; then
							dll_reg_manager="$_reg_class,$_reg_elf,$_reg_dlls"; ((M++))
						else
							dll_reg_manager=''
						fi
					else
						local $_var=''
					fi
				fi
			fi
		done
		if [[ $(printf "$user_edit"| grep -c .) -gt 0 || \
		$(printf "$user_edit"| grep -c "option_set") -gt 0 ]]; then
			for _new_reg in $(echo -e "$user_edit"); do
				## form: "DirectDrawRenderer"="gdi"
				## for regex form: (")(DirectDrawRenderer)(")=(")(gdi)(?>:0..1)(")
				regex='([\"]?)(\w*)([\"]?)=([\"]?)(\w*)([:[0-9]*]?)([\"]?)$'
				_var=$(echo "$_new_reg"| sed -E -n "s/$regex/\2/p")
				_val=$(echo "$_new_reg"| sed -E -n "s/$regex/\5\6/p")
				## check first if editable values are not previously unset before adding anything to reg.
				eval _pre_var='$'$_var
				if [[ $_pre_var != unset ]]; then
					if [ $(echo "${_reged_var[*]}"| grep -c "$_var" ) -eq 0 ]; then
						if [[ $_val =~ dword: ]]; then
							_reged_var+=("\"$_var\"=$_val")
						else
							_reged_var+=("\"$_var\"=\"$_val\"")
						fi
					fi
				fi
			done
		fi
		if [ ${#_reged_var[*]} -gt 0 ]; then
#			reg_final=$(echo -e "[HKEY_CURRENT_USER\\\\Software\\\\Wine\\\\Direct3D]\n${_reged_var[*]}")
			reg_final=$(echo -e "[HKEY_CURRENT_USER\\\\\\\Software\\\\\\\Wine\\\\\\\Direct3D]\n${_reged_var[*]}")
			((M++))
		else
			reg_final=''
		fi
		if [ $M -gt 0 ]; then _reged=1; fi
#		_reged=1
		newconf_reged
	}
	newconf_reged(){
		_section="## extra wine registry specific entry
## leave user_reg blank if none : user_reg=''
## possible values are:
## \"StrictDrawOrdering\"=\"enabled\/disabled\"
## \"DirectDrawRenderer\"=\"opengl\"
## \"Nonpower2Mode\"=\"repack\"
## \"OffscreenRenderingMode\"=\"fbo\"
## \"RenderTargetLockMode\"=\"auto\"
## \"UseGLSL\"=\"readtex\"
## \"VideoMemorySize\"=\"(memory size of your graphic card)\"
user_reg='$reg_final'
## Allow local system apps to launch some mime-file type:
local_association=\"$local_association\"
## Register/unsregister DLLs libraies (one arch at a time):
## example: 1,0,foo.dll,poo.dll,
## Where first 1 is register and 0 unregister and secondary 0/1 is wine32/wine64, 2 is both
dll_reg_manager=\"$dll_reg_manager\"
## Do not remove or edit below except if you don't use winestarter configurator.
_reged=$_reged"
	}
	reconf_nvidia_1(){
		[[ $code_tag = 0 ]]|| echo -e "$g_notif\n##### reconf_nvidia_1 $e_notif"
		M=0
		local ${_out_conf_sets[@]}
		
		for _list in ${_out_conf_sets[@]}; do
			_var=$(printf "$_list"|cut -d'=' -f1)
			_val=$(printf "$_list"|cut -d'=' -f2)
			if [[ $_val != unset ]]; then
				case $_var in
				'__GL_FSAA_MODE')
					## fsaa mode comes with special text options to be convert in numerics for control type,
					## and multiplier has to be converted from 1,2,3,4,5 conf value to driver's one.
					if [ $__GL_FSAA_MODE -gt 0 ]; then
						case $__GL_FSAAA_CTRL in
							'full control') __GL_FSAAAppControlled=0; __GL_FSAAAppEnhanced=0 ;;
							'enhanced') __GL_FSAAAppControlled=0; __GL_FSAAAppEnhanced=1 ;;
							'ignored') __GL_FSAAAppControlled=1; __GL_FSAAAppEnhanced=1 ;;
						esac
						local cmt__GL_FSAAAppControlled='export'
						local cmt__GL_FSAAAppEnhanced='export'
						case $__GL_FSAA_MODE in
							'2') __GL_FSAA_MODE=5;;
							'3') __GL_FSAA_MODE=9;;
							'4') __GL_FSAA_MODE=10;;
							'5') __GL_FSAA_MODE=11;;
						esac
						local cmt$_var='export'; ((M++))
					else
						local cmt__GL_FSAA_MODE='#export'
						local cmt__GL_FSAAAppControlled='#export'
						local cmt__GL_FSAAAppEnhanced='#export'
					fi
#				fi
				;;
				'__GL_LOG_MAX_ANISO')
					if [ $_val = 0 ]; then
						local cmt$_var='#export'
					else
						local cmt$_var='export'; ((M++))
					fi
				;;
#				`printf "$_var"| egrep '^__GL_[AL|TH|SY|Op].*$'` ) local cmt$_var='export' ;;
				*) local cmt$_var='export'; ((M++)) ;;
				esac
			else
				local $_var=0
				local cmt$_var='#export'
			fi
		done
		if [ $M -gt 0 ]; then _nvidia_1=1; fi
		newconf_nvidia_1

	}
	newconf_nvidia_1(){
		_section="### NVIDIA ENV VARIABLE OPTIONS
## FSAA: Full Scene Anti Aliasing: can be set from 1 to 5:
## off [0], 2x (2xMS) [1], 4x (4xMS) [5], 8x (4xSS, 2xMS) [9], 8x (8xMS) [10], 16x (4xSS, 4xMS) [11]
$cmt__GL_FSAA_MODE __GL_FSAA_MODE=$__GL_FSAA_MODE
## if set, FSAA comes 2 others variables that have to be set as follow respectively :
## To get FSAA full control: [0] [0]
## To get FSAA enhanced for application using multisample : [0] [1]
## To get FSAA controlled by nvidia-setting ignored : [1] [1]
$cmt__GL_FSAAAppControlled __GL_FSAAAppControlled=$__GL_FSAAAppControlled
$cmt__GL_FSAAAppEnhanced __GL_FSAAAppEnhanced=$__GL_FSAAAppEnhanced
## FXAA, Fast approximate antialiasing: take avantage over traditional multisampling and
## supersampling methods: (0) (1)
$cmt__GL_ALLOW_FXAA_USAGE __GL_ALLOW_FXAA_USAGE=$__GL_ALLOW_FXAA_USAGE
## anisotropic texture filtering set : off (0), x2 (1), x4 (2), x8 (3), x16 (4)
$cmt__GL_LOG_MAX_ANISO __GL_LOG_MAX_ANISO=$__GL_LOG_MAX_ANISO
## synchronize vertical refresh (0), (1)
$cmt__GL_SYNC_TO_VBLANK __GL_SYNC_TO_VBLANK=$__GL_SYNC_TO_VBLANK
## if libpthread is not enabled by default (ex: wine),
## it can be force to be set with LD_PRELOAD env variable.
$cmt__GL_THREADED_OPTIMIZATIONS LD_PRELOAD=\"libpthread.so.0 libGL.so.1\" __GL_THREADED_OPTIMIZATIONS=$__GL_THREADED_OPTIMIZATIONS
## Perfomance from Nvidia Settings tool can be set to gain graphic performance instead of quality
## Quality (1), Mixed (2), Perfomance (3), otherwise comment it to unset.
$cmt__GL_OpenGLImageSettings __GL_OpenGLImageSettings=$__GL_OpenGLImageSettings
## Do not remove or edit below except if you don't use winestarter configurator.
_nvidia_1=$_nvidia_1"
	}
	reconf_nvidia_2(){
		[[ $code_tag = 0 ]]|| echo -e "$g_notif\n##### reconf_nvidia_2 $e_notif"
		local ${_out_conf_sets[@]}
		M=0
		for _list in ${_out_conf_sets[@]}; do
			_var=$(printf "$_list"|cut -d'=' -f1)
			_val=$(printf "$_list"|cut -d'=' -f2)
			if [[ $_val != unset ]]; then
				local cmt$_var='export'
				((M++))
			else
				if [[ $_var == __GL_YIELD ]]; then _val=''; else _val=0; fi
				local $_var=$_val
				local cmt$_var='#export'
			fi
		done
		if [ $M -gt 0 ]; then _nvidia_2=1; fi
		newconf_nvidia_2
	}
	newconf_nvidia_2(){
		_section="### NVIDIA MISCELLENOUS OPTIONS
## VBLANK can't bet set for multi screen, set here one of them only (if needed):
$cmt__GL_SYNC_DISPLAY_DEVICE __GL_SYNC_DISPLAY_DEVICE=\"$__GL_SYNC_DISPLAY_DEVICE\"
## to set or unset X server FBConfig behaviour : unset [0], set [1]
$cmt__GL_SORT_FBCONFIGS __GL_SORT_FBCONFIGS=$__GL_SORT_FBCONFIGS
## updating window moves yield, can be useful when some window app have refresh issues,
## value are : normal yield (''), no yield [\"NOTHING\"], background [\"USLEEP\"]
$cmt__GL_YIELD __GL_YIELD=\"$__GL_YIELD\"
## allow unofficial GLX implmentation. Mostly for debug mode or test, but can be useful
## in some case like Wine : off [0], on [1]
$cmt__GL_ALLOW_UNOFFICIAL_PROTOCOL __GL_ALLOW_UNOFFICIAL_PROTOCOL=$__GL_ALLOW_UNOFFICIAL_PROTOCOL
## if monitor can manage G-SYNC behaviour, this could improve display performance: off [0], on [1].
## Disable __GL_SYNC_TO_VBLANK to get faster performance and also xorg conf options \"stereo\", \"overlays\"
$cmt__GL_GSYNC_ALLOWED __GL_GSYNC_ALLOWED=$__GL_GSYNC_ALLOWED
## ignore GLGS extension check. Could be useful in case of some missing extension in appli GL sets.
## This will permit the shaders to be successfuly recompile: to off [0], on [1]
$cmt__GL_IGNORE_GLSL_EXT_REQS __GL_IGNORE_GLSL_EXT_REQS=$__GL_IGNORE_GLSL_EXT_REQS
## Do not remove or edit below except if you don't use winestarter configurator.
_nvidia_2=$_nvidia_2"
	}
	reconf_xrandr(){
		[[ $code_tag = 0 ]]|| echo -e "$g_notif\n##### reconf_xrandr $e_notif"
		local ${_out_conf_sets[@]}
		M=0
		# bck_mode=1920x1080 set_mode=1280x720 'default_desktop=compiz ccp' secondary_desktop=marco 'mouse_dev=Logitech K230' 'set_buttons=3 2 1'
		for _list in ${_out_conf_sets[@]}; do
			_var=$(printf "$_list"|cut -d'=' -f1)
			_val=$(printf "$_list"|cut -d'=' -f2)
			if [ $_val != unset ]; then
#					'bck_mode') set_xrandr="xrandr --output $monitor --mode $_val --rate 60"; auto_set=1 ;;
#					'set_mode') bck_xrandr="xrandr --output $monitor --mode $_val --rate 60";;
				case $_var in
					'bck_mode') bck_xrandr="xrandr --output $monitor --mode $_val --rate 60"; auto_set=1 ;;
					'set_mode') set_xrandr="xrandr --output $monitor --mode $_val --rate 60";;
					'default_desktop'|'secondary_desktop')
						if [[ $_val == mate ]]; then local $_var='marco'; fi
						if [[ $_val == compiz ]]; then local $_var='compiz ccp'; fi
						set_desktop_env=1
					;;
					'mouse_dev')
						mice=$(printf "${xinput_list[@]}"| grep "$mouse_dev")
						mice_nm=$(printf "$mice"| cut -d';' -f1)
						mice_id=$(printf "$mice"| cut -d';' -f2|sed -n "s/^.*=//p")
						if [[ $(printf "$mice_nm"| grep -c "$_val") -gt 0 ]]; then
							set_dev_id=$mice_id
						fi
						if [ $set_buttons == unset ]; then set_buttons='1 2 3'; fi
						mouse_btn="xinput set-button-map $set_dev_id $set_buttons"
						mouse_set=1
					;;
				esac
				((M++))
			else
#					'bck_mode') local $_var=''; auto_set=0 ;;
				case $_var in				
					'set_mode') local $_var=''; auto_set=0 ;;
					'default_desktop'|'secondary_desktop') local $_var=''; set_desktop_env=0 ;;
					mouse_dev) local $_var='' ; mouse_set=0 ;;
					*) local $_var='';;
				esac
			fi
		done
		if [ $M -gt 0 ]; then _xrandr=1; else _xrandr=0; fi
		newconf_xrandr
	}
	newconf_xrandr(){
		_section="## optional xrandr command set, useful when you have strange fullscreen beshavior
## set enable (1) or disable (0)
auto_set=$auto_set
## fullscreen mode for your app ex: xrandr --output HDMI-1 --mode 1280x720 --rate 60
set_xrandr='$set_xrandr'
## your default screen mode
bck_xrandr='$bck_xrandr'

## optional desktop environment replacement:
## This option allow you to replace a buggy enduser graphical environment
## by a lighter one (OpenGl glitch, etc). This suppose a second desktop UI is already installed.
## set enable (1) or disable (0)
set_desktop_env=$set_desktop_env
## selec the default UI and replacement UI
default_desktop='$default_desktop'
secondary_desktop='$secondary_desktop'
## reverse mouse button
mouse_set=$mouse_set
mouse_dev='$mouse_dev'
mouse_btn='$mouse_btn'
## Do not remove or edit below except if you don't use winestarter configurator.
_xrandr=$_xrandr"
	}
	reconf_optimus(){
		[[ $code_tag = 0 ]]|| echo -e "$g_notif\n##### reconf_optimus $e_notif"
		local ${_out_conf_sets[@]}
		M=0
		for _list in ${_out_conf_sets[@]}; do
			_var=$(printf "$_list"|cut -d'=' -f1)
			_val=$(printf "$_list"|cut -d'=' -f2)
			if [ $_val != unset ]; then
				case $_var in
					'opti_starter') use_optimus=1 ;;
					'opti_accel')
						if [[ $opti_starter == primusrun ]]; then
							opti_accel=''
							opti_SYNC=''
						fi
					;;
				esac
				((M++))
			else
				case $_var in
					'opti_starter') use_optimus=0 ;;
				esac
				local $_var=''
			fi
		done
		if [ $use_optimus = 0 ]; then
			opti_sets=('opti_accel' 'opti_SYNC' 'opti_VBLK')
			for _set in ${opti_sets[@]}; do local $_set=''; done
			_optimus=0
		else
			if [ $M -gt 0 ]; then _optimus=1; else _optimus=0; fi
		fi
		newconf_optimus
	}
	newconf_optimus(){
		_section="## Optimus starter with options
## comment if you don't need them.
## Set if you want to use Optimus laptop display:
use_optimus=$use_optimus
## Set the optimus starter : 'optirun', 'primusrun'.
opti_starter=\"$opti_starter\"
## Set optirun vitualizer: 'virtualgl', 'primus'.
## If using 'primusrun' or 'Bumblebee default' leave 'opti_accel' blank ('')
opti_accel=\"$opti_accel\"
## Optimus images sync behaviour env option.
opti_SYNC=$opti_SYNC
## Optimus Vertical sync behavior, prefered is usualy off (0)
## Set enable (1) or disable (0)
opti_VBLK=$opti_VBLK
## Do not remove or edit below except if you don't use winestarter configurator.
_optimus=$_optimus"
	}
################################
## Yad UI messages and main text	
	messages(){
		main_tab_text="$bf Select settings by theme$end$nf\\n \
 Items or section leave \'unset\' or empty will not be set to the Winestarter config file$end"
		msg_wine="Set a new Wine prefix"
		msg_wcfg="Set a custom Wine binary"
		msg_tricks="Winetricks packages install (Windows packages)"
		msg_install="Install a Windows Software"
		msg_reged="Configure associated Wine registry sets (useful)"
		msg_nvidia1="Set Nvidia common OpenGL options (optional)"
		msg_nvidia2="Set Nvidia miscellenous options (extra)"
		msg_xrandr="Set XRandr game display geometry (optional)"
		msg_optimus="Set optimus specific options (optional)"
		msg_wine_opts="Set Wine specific options (optional)"
		msg_extended="Set extended features (very optional)"
		_warn_text="## Do not remove or edit below except if you don't use winestarter configurator."
	}
## Main Yad function
	fn_create_prefix(){
		## launch winetricks list building separatly before all ops,
		## otherwise it takes too much time when tabs are in building process.
		fn_tricks_list_build &
		unset form_win def_win default_win
		unset tab_set tab_temp cfg_set t_display nv_field
		hq_stb0=$(printf "$_hq_stb0"| cut -d',' -f1)
		hq_stg0=$(printf "$_hq_stg0"| cut -d',' -f1)
		hq_dev0=$(printf "$_hq_dev0"| cut -d',' -f1)
		if [ $use_winepath -gt 0 ]; then
			active_wine=$wine_ver
		else
			active_wine=$sys_version
		fi
#		_target_conf=$(printf "$bottle_prefix"|  sed -n "s/^.*[\/.\|.]\(\w*[Aa-Zz]\.\w*[Aa-Zz]*\)/\1/g;p")
		_target_conf=$(printf "$bottle_prefix"|  sed -En "s/^.(.*)$/\1/g;p")
		if [[ $_target_conf ]]; then target_conf=$_target_conf; fi
#		main_tab_text="$bf\\Select settings by theme$end \\n \
#$nf\\Items or section leave \'unset\' or empty will not be set to the Winestarter config file$end \\n \
#$nf\\Last dowloadable:$end$vb PlayOnLinux >$end wine32 $_pol32, wine64 $_pol64\\n \
#$vb\\WineHQ (32/64) >$end $hq_stg0, $hq_dev0, $nf\\System >$end $sys_version"
		main_tab_text="$bf\\Select settings by theme$end $brf$target_conf$end\\n
$nf\\Items or section leave \'unset\' or empty will not be set to the Winestarter config file$end \\n \
$nf\\Last WineHQ versions >$end $hq_stb0, $hq_stg0, $hq_dev0,$nf System >$end $sys_version"
		w_text="$bf Wine prefix$end $brf$target_conf$end
$vb\\Set wine prefix name, appli/game directories, etc.$end\\n
$nf\\Check here the sections you would like to configure.$end"
		w_title="Wine Start Config"
		w_title1="$vb Nvidia OpenGL options$end"
		w_title2="$vb Miscellenous options$end"
		w_title3="$vb Advanced features$end"
		w_sub_3="Checking this option will allow extended features for advanced users"
		wine_tip0="$vb Main prefix install sections$end"
		wine_version="$vn\\Actual prefix Wine binary : Wine $active_wine$end"

		## if Nvidia device is present, add it to menu entries.
		if [ $($lpci_bin| grep -c "NVIDIA") -gt 0 ]; then
			nv_field="'';;;;LBL;;
'';;;$w_title1;LBL;;
$_nvidia_1;_nvidia_1;Nvidia*(common);$msg_nvidia1;CHK;fn_nvidia_config_1;$img_nv_cm
$_nvidia_2;_nvidia_2;Nvidia*(extra)*;$msg_nvidia2;CHK;fn_nvidia_config_2;$img_nv_ext"
		fi
		## set IFS to include white space.
		ifs=$IFS
		IFS=$(echo -ne "\n\b")
		basic_sets="'';;;;LBL;;
'';;;$wine_tip0;LBL;;
$_wine;_wine;Wine*basics**;$msg_wine;CHK;fn_wine_config;$img_wine_cfg1
$_wbin;_wbin;Extra*binary**;$msg_wcfg;CHK;fn_wine_binary;$img_wine_cfg2
$_install;_install;Install*Software;$msg_install;CHK;fn_install_soft;$img_install
$_tricks;_tricks;Install*tricks**;$msg_tricks;CHK;fn_winetricks;$img_tricks
$_reged;_reged;Registry*options*;$msg_reged;CHK;fn_regedit_config;$img_reged
${nv_field[@]}
'';;;;LBL;;
'';;;$w_title2;LBL;;
$_xrandr;_xrandr;Display*options**;$msg_xrandr;CHK;fn_xrandr_config;$img_xrandr
$_optimus;_optimus;Optimus*options**;$msg_optimus;CHK;fn_optimus_config;$img_opti
'';;;;LBL;;
'';;;$w_title3;LBL;;
'';;;$w_sub_3;LBL;;
$_extended;_extended;;$msg_extended;CHK;;
'';;;;LBL;;
'';;;$wine_version;LBL;;"
		## restore temporarly IFS.
		IFS=$ifs
		## item separator in output list
		item_sep=","
		## window style and function.
		win_type=0
		borders='--borders=15'
		w_width='420'
		main_height='--height=420'
		main_scroll='--vscroll-policy=auto'
		extend_height='--height=400'
		extend_pol='--scroll'
		default_win_design
		# create main window variables.
		default_tab_design
		# export main function variables.
		default_tab_create
	}
	fn_nvidia_config(){
		# launch default start window
		w_title="Wine Starter"
		main_tab_text="$bf Reconfigure Nvidia's settings$end$nf\\n \
 Items leave \'unset\' will not be set to the Winestarter config file$end"

		tab_set=("1;_nvidia_1;Nvidia*(common);fn_nvidia_config_1;$img_nv_cm
2;_nvidia_2;Nvidia*(optional);fn_nvidia_config_2;$img_nv_ext")
		item_sep=","
		# window style and function
		win_type=1
		w_width='420'
		main_height='--height=420'
		main_scroll='--vscroll-policy=auto'
		extend_height='--height=400'
		extend_pol='--scroll'
		# create main window variables
		default_tab_create
	}
	fn_binary_env(){
		if ! [ -s $HOME/.winestarter/default-wine ]; then
			fn_binary_config
		fi
#		else
		wine_path=$(cat $HOME/.winestarter/default-wine| cut -d';' -f2)
#		wine_elf=$(cat $HOME/.winestarter/default-wine| cut -d';' -f3)
		## detect system master elf type. 
		if ! [ $wine_elf ]; then
			if [[ $(uname -m) =~ ^.*64 ]]; then wine_elf=1, else wine_elf=0; fi
		fi
		## set .wienbin folder type as appropriate after detect.
		if [ $wine_elf = 1 ]; then	dir_elf='amd64'; else dir_elf='x86'; fi
		## check out box wine version if any.
		wine_ver_default=$(cat $HOME/.winestarter/default-wine| cut -d';' -f1)
		## set it as default system version is exist and set. 
		if [ $wine_ver_default ]; then
			if ! [ $sys_version ]; then sys_version=$wine_ver_default; fi
		fi
		## check if selected config file have a specific version set.
		if [ $from_config = 1 ]; then
			if [ $use_winepath -gt 0 ]; then wine_ver=$wine_ver; else wine_ver=$wine_ver_default; fi
		else
			wine_ver=$wine_ver_default
		fi
		## set wine environment variables as appropriate from above settings.
		wine_elf_path=$wine_path/$dir_elf/$wine_ver
		export WINEVERPATH=$wine_elf_path
		export PATH=$wine_elf_path/bin:$PATH
		export WINESERVER=$wine_elf_path/bin/wineserver
		export WINELOADER=$wine_elf_path/bin/wine
#		export WINEREGEDIT=$wine_elf_path/bin/regedit
		if [ $wine_elf = 1 ]; then
			export WINEDLLPATH=$wine_elf_path/lib64/wine/fakedlls
			export LD_LIBRARY_PATH=$wine_elf_path/lib:$wine_elf_path/lib64:$LD_LIBRARY_PATH
		else
			export WINEDLLPATH=$wine_elf_path/lib/wine
			export LD_LIBRARY_PATH="$wine_elf_path/lib:$LD_LIBRARY_PATH"
		fi
		wine_bin=$WINELOADER
#		sys_version=$($wine_bin --version)
		use_winepath=1
#		wine_pack=1
		_wbin=1
		wine_bin_path=$wine_elf_path/bin/
#		${wine_bin_path}wineboot -i
#		sys_version=$($wine_bin --version)
		## then, start as usual 
		if [ $b_set = 1 ]; then
			fn_basics_config
		else
			fn_create_prefix			
		fi
	}
	fn_binary_config(){
		# launch default start window
		w_title="Download and install Wine"
		w_text="$rb\\WARNING$end$vb : Wine executables and librairies are missing\\n\
To use Winestarter or Winetricks you must install them with your\\n\
packages manager or directly from WineHQ staging below.$end"
		w_wine_conf_path0="$vb\\Set full path where the Wine package will be installed:$end"
		w_wine_conf_path1="$vn(default is set to: $HOME/.winebin)$end"
		w_wine_conf_path01="$rb\\Pay attention$end$vb : Previous wine binaries path detected. Select one from the list below or download a new one.$end"
		w_wine_conf_path02=""
		w_wine_conf_path03=""
		w_wine_conf_txt="$nf\\Set full path$end"
		w_wine_conf_txt1="$nf\\Select package from default Wine path$end"
		w_wine_conf_txt2=""
		w_wine_conf_txt3=""
		w_wine_binary_tip="$vb\\You can choose any version from the selector, bust last is prefered.$end"
#		set_as_default_tip="$vb\\When set to default, installed package will be available to all future bottles, until you choose a different one for a specific usage.$end"
		set_as_default_tip="$vb\\Installed package is set as default and will be available to all future bottles, until you choose a different one for a specific usage.$end"
#		set_as_default=" Set package as default"
#		set_64_tip="$vb\\You can set the whole environment to 64bits bottles, but it's not recommanded for a flexible usage.$end"
#		set_64=" Set 64bits environment only"
	
		# x_width=$(xwininfo -stats -name "$w_title"| sed -E -n "s/^ +Width: +([0-9]+)/\1/p")
		width=520
		borders='15'
		win_image=$img_wine_ui
		c_chain=30
		out=$(printf "%0.s " $( seq 1 $c_chain))
		default_bin_dir=$HOME/.winebin
#		wine_dis_cmd="bash $bash_opt \"select_wine_dis\""
		
		ifs=$IFS
		IFS=$(echo -en "\n\b")
		n=0
## TODO < REMOVE
#		_basics_fields="$w_wine_binary_tip;LBL;''
#$vb click and select a WineHQ package$end,$img_winedis_bt;FBTN;$wine_dis_cmd
#$set_as_default_tip;LBL;''
#$set_as_default;CHK;FALSE"
#		_basics_fields="$w_wine_binary_tip;LBL;''
#$vb WineHQ staging package$end;CB;unset#$_hq_stg0_list
#$vb WineHQ staging package (older)$end;CB;unset#$_hq_stg1_list
#$set_as_default_tip;LBL;''
#$set_as_default;CHK;FALSE"
		_basics_fields="$w_wine_binary_tip;LBL;''	
$vb WineHQ staging package$end;CB;unset#$_hq_stg0_list
$vb WineHQ staging package (older)$end;CB;unset#$_hq_stg1_list
$set_as_default_tip;LBL;''"
#		_basics_64="$set_64_tip;LBL;''
#$set_64;CHK;FALSE"
		## define system elf type and download destination
		if [[ $(uname -m) =~ ^.*64 ]]; then
			export wine_elf=1
			http_elf='x86_64'; dir_elf='amd64'; b_elf='64'
#			_basics_fields=$(echo -e "$_basics_fields\n$_basics_64")
#			_basics_fields="$_basics_fields
#$_basics_64"
		else
			export wine_elf=0
			http_elf='i686'; dir_elf='x86'; b_elf=''
		fi
		if [[ -d $HOME/.winebin ]]; then
			if [ $(ls -1 $HOME/.winebin| grep -c .) -gt 0 ]; then
				export wine_path=$HOME/.winebin
#				if [[ $(uname -m) =~ ^.*64 ]]; then dir_elf='amd64'; else dir_elf='x86'; fi
				existing_list=$(ls -1 $HOME/.winebin/$dir_elf/| tr '\n' '#'| sed -n "s/#$//g;p")
				_more_basics=";LBL;''
$w_wine_conf_path01;LBL;''
$w_wine_conf_path1;LBL;''
$w_wine_conf_txt$nf$out$end;CDIR;$default_bin_dir
$w_wine_conf_txt1;CB;unset#$existing_list"
			_basics_fields="$_more_basics
$_basics_fields"
			fi
			n=1
		else
			_more_basics=";LBL;''
$w_wine_conf_path0;LBL;''
$w_wine_conf_path1;LBL;''
$w_wine_conf_txt$nf$out$end;CDIR;$default_bin_dir"
			_basics_fields="$_more_basics
$_basics_fields"
		fi
		_field_regex='^(.*);(.*);(.*)$'
		_fields=( $(echo -e "$_basics_fields"| sed -En "s/$_field_regex/--field=\1:\2/p") )
		_fields_sets=( $(echo -e "$_basics_fields"| sed -En "s/$_field_regex/\3/p") )
		wine_bin_output=$( $yad_bin --width=$width --title "$w_title" --separator=';'  \
		--item-separator='#' --window-icon=$img_wine_desk_ui --align=left --borders=$borders \
		--form --text="$w_text" --image=$win_image \
		"${_fields[@]}" "${_fields_sets[@]}")
		if [ $? = 1 ]; then exit 0; fi
		IFS=$ifs
		
		## set data coming fron the yad ui. 
		use_winepath=1
		wine_path=$(printf "$wine_bin_output"| cut -d';' -f4)
		wine_default=$(printf "$wine_bin_output"| cut -d';' -f$((9+$n)))
		wine_ver_list=( $(printf "$wine_bin_output"|\
		cut -d';' -f$((6-$n))-$((7+$n))| sed -En "s/(;|;;)/\ /g;p") )
		if [ ${#wine_ver_list[@]} -gt 0 ]; then
			if [ ${#wine_ver_list[@]} -gt 2 ];then
				for _wine_ver in ${wine_ver_list[@]}; do
					if [[ $_wine_ver != unset ]]; then
						if [ $(ls -1 $HOME/.winebin/$dir_elf/$_wine_ver| grep -c .) -eq 0 ]; then
							stage_list=( '_hq_stg0,1' '_hq_stg1,2' )
							for stage in ${stage_list[@]}; do
								_hq_stage=$(printf "$stage"| cut -d',' -f1)
								if [ $(cat $HOME/.winestarter/resources/ftp$_hq_stage.\[list\]|\
								grep -c "$_wine_ver") -gt 0 ]; then
									wine_ver=$(cat $HOME/.winestarter/resources/ftp$_hq_stage.\[list\]|\
									grep "$_wine_ver"|cut -d',' -f1)
									
									dist_dl_ver=$(cat $HOME/.winestarter/resources/ftp$_hq_stage.\[list\]|\
									grep "$_wine_ver"|cut -d',' -f2)
									pkg_ver=$(printf $wine_ver| cut -d'-' -f1)
									pkg_rel=$(printf $wine_ver| cut -d'-' -f2)
	#								wine_build=$(printf "$stage"| cut -d',' -f2)
									wine_pack=$(printf "$stage"| cut -d',' -f2)
								fi
							done
							exec_dl=1
						else
							wine_ver=$(printf "$_wine_ver"| sed -n "s/*$//g;p")
							wine_pack=''
							exec_dl=0
						fi
					fi
				done
				if [ $exec_dl = 1 ]; then
					## create tmp dir for package download
					dl_dir=$(mktemp --tmpdir -d wine_dl.XXXX)
					## control if wine bin dir exist. If not create it from default
					if ! [ -d $wine_path/$dir_elf/ ]; then mkdir -p $wine_path/$dir_elf; fi
					## Define old or recent
					if [ $wine_pack = 1 ]; then dir_ver='wine-builds.old'; else dir_ver='wine-builds'; fi
					## define download source and packages
					dl_address_0="https://dl.winehq.org/$dir_ver/fedora/$dist_dl_ver/$http_elf"
					dl_address_1="https://dl.winehq.org/$dir_ver/fedora/$dist_dl_ver/i686"
					dl_list=(
						"$dl_address_0/wine-staging$b_elf-$pkg_ver-$pkg_rel.$http_elf.rpm"
						"$dl_address_1/wine-staging-common-$pkg_ver-$pkg_rel.i686.rpm"
					)
					unpack_list=(
						"wine-staging$b_elf-$pkg_ver-$pkg_rel.$http_elf.rpm"
						"wine-staging-common-$pkg_ver-$pkg_rel.i686.rpm"
					)
	#				echo "${dl_list[@]}"
	#				exit 0
					## download command
					dl_cmd(){ wget -P $dl_dir $pkgs 2>&1; }
					## This perl regex Analyse and parse wget stdout field, then display it in a yad window
					track(){ perl -p -e "$| = 1; s/^.* +([0-9]+%) +([0-9,.]+[GMKB]) +([0-9hms,.]+).*$/\1\n# $pack_name [\1] time left: \3\t\2\/s/"; }
					## now download
					cd $dl_dir
					for pkgs in ${dl_list[@]}; do
						pack_name=$wine_ver
						## download UI feeds
						pkg_ext=$(printf "$pkgs"| sed -n "s/^.*\.//p")
						site=$(printf "$pkgs"| sed -E -n "s/(^.*:\/\/)(\w+)\.(\w+)\.(\w+)\/.*$/\2.\3.\4/p")
						pack=$(printf "$pkgs"| sed -n "s/^.*\///p")
						w_text="$vb\\Downloading $pack\\nfrom $site server.$end"
						## download progress bar UI
						dl_cmd|track|$yad_bin --width=550 --title "$w_title" --align=center --borders=$borders \
						--text="$w_text" --window-icon=filesave --image=$img_install --progress --auto-close
						if [ $? = 1 ]; then exit 0; fi
					done
					## then, extract to wine bin directory
					if [ $(ls -1 $dl_dir| egrep -c "$pkg_ver") -gt 0 ]; then
						for dwld in ${unpack_list[@]}; do
							e_text="$vb\\Extracting $dwld to $wine_path.$end"
							$yad_bin --width=550 --title "$w_title" --align=center --no-buttons \
							--borders=$borders --window-icon=filesave --progress --pulsate --auto-close \
							--text="$e_text" --progress-text="" &
							## seek the extrat UI yad PID
							WAIT_UI=$(ps -A | grep "yad" | awk '{print $1}'| sed -n '1p')
							## extract rpm command through rpm2cpio
							$rpm_bin $dwld | cpio -id
							kill $WAIT_UI
						done
						mkdir -p $wine_path/$dir_elf/$wine_ver/
						cp -Rf opt/wine-staging/* $wine_path/$dir_elf/$wine_ver/
						if [ $b_elf = 64 ]; then cd $wine_path/x86; ln -sf ../$dir_elf/$wine_ver ; fi
					fi
				fi
			else
#				wine_ver=$(printf "$wine_bin_output"| cut -d';' -f5)
				wine_ver=${wine_ver_list[0]}
				wine_pack=''
			fi
		fi
## TODO < REMOVE
		## set if Wine env have to be set as default or not.
#		if [[ $wine_64 == TRUE ]]; then default_elf=1; else default_elf=0; fi
#		if [[ $wine_default == TRUE ]]; then printf "$wine_ver;$wine_path;$wine_elf" \
#		if [[ $wine_default == TRUE ]]; then printf "$wine_ver;$wine_path" \
#		> $HOME/.winestarter/default-wine; fi
		printf "$wine_ver;$wine_path" > $HOME/.winestarter/default-wine
	}
	fn_tricks_list_build(){
		if [[ -x "$w_tricks_bin" ]]; then
			w_tricks_reserve=$HOME/.winestarter/resources/tricks_workaround.txt
			w_tricks_dlls=$HOME/.winestarter/resources/tricks_dlls.txt
			if [[ -d $user_prefix/$bottle_prefix || $from_config = 1 ]]; then
				## let some time to winetricks to start building its list,
				## otherwise it could be confused during tab creation phase. 
				wait_message='BUILDING WINETRICKS LIST'
				on_top='--on-top '
				if ! [[ -s $w_tricks_reserve || -s $w_tricks_dlls ]]; then
					fn_plz_wait &
					WAIT_UI_3=$(ps -A | grep "yad" | awk '{print $1}'| sed -n '1p')
					sleep 1
					## set default arch
					if [ $wine_elf = 1 ]; then winearch='win64'; else winearch='win32'; fi
					## set default env
					export WINEARCH=$winearch
					export WINEPREFIX="$user_prefix/$bottle_prefix"
					## now look for winetricks settable dlls and put them in a tmp file
					$w_tricks_bin dlls list| grep "downloadable" >$w_tricks_dlls
					## create winetricks workaround list for winetricks log filtering
					$w_tricks_bin settings list|sed -n "/^---/,/---$/d;p"| egrep -v "^Using.*$"| \
					awk '{print $1}' >$w_tricks_reserve
					kill $WAIT_UI_3
				fi
			fi
			dlls_list=$(cat $w_tricks_dlls| awk '{print $1}'| tr '\n' ',')
		fi
	}
	fn_basics_config(){
		unset  tab_set tab_temp cfg_set t_display form_win 
		# launch default start window
		w_title="Winestarter"
		main_tab_text="$bf Configure Wine initial sets$end$nf\\n \
 It will create a basic Wine bottle, mainly useful if you plan to use an already\\n \
 existing app directory.$end"
		_wine=1
		tab_set=("1;_wfirst;Basics;fn_wine_basics;$img_wine_desk_ui")
		item_sep=","
		# window style and function
		win_type=1
		# create main window variables
		default_tab_create
	}
	fn_wine_basics(){
		[[ $code_tag = 0 ]]|| echo -e "$g_notif\n>>>> start fn_wine_basics ####\n$e_notif"
		unset basic_sets track_list # #
		# window messages
		w_wine_basic_tip=""
		w_wine_user_prefix="$vb\\Set user prefix if not the user's default one:$end"
		w_wine_prefix="$vb\\Set the Wine Bottle prefix to use:$end"
		w_wine_prefix_tip="$vb\\Example:$end$nf wine.my_bottle$end, no space. \"$nf\\wine.$end\" prefix is mandatory."
		w_wine_game_path="$vb\\Set the full game/appli directory if different from bottle:$end"
		w_wine_elf_tip_0="$rb\\Note$end: 32bits apps can be launch from a Wine 64bits install (from Wine 2.0 and above). In my own experience, it enhance globaly app performances. (Don't for XP bottle 32bits apps)"
		w_wine_elf_tip_1="$rb\\Warning$end: Winetarter manage "
		w_text="$bf\\Configure the Wine basic environment$end"
		
		track_list="user_prefix bottle_prefix game_path wine_elf"

		for trk_set in ${track_list[@]}; do
			unset local_set
			if [[ $trk_set == wine_elf ]]; then trk_box=0; else trk_box="$HOME/"; fi
			local_set+=("$trk_set=$trk_box")
			local $local_set
		done
		
		ifs=$IFS
		IFS=$(echo -en "\n\b")
		basic_sets="'';;;;LBL;;
'';;;$w_wine_user_prefix;LBL;;
$user_prefix;user_prefix;;$nf Default Wine user prefix$end;DIR;;
'';;;$w_wine_prefix;LBL;;
'';;;$w_wine_prefix_tip;LBL;;
wine.mybottlename;bottle_prefix;;$nf Bottle prefix$end;;;
'';;;$w_wine_game_path;LBL;;
$game_path;game_path;;$nf Existing appli path$end;DIR;;
'';;;$w_wine_elf;LBL;;
'';;;$w_wine_elf_tip_0;LBL;;
$wine_elf;wine_elf;;Set bottle type as 64 bits (global environment);CHK;;"
#$wine_app_elf;wine_app_elf;;Application type is full 64 bits;CHK;;"
		item_sep=","
		IFS=$ifs
		from_config=0
		focus='--focus-field=6'
		# window style and function
		win_type=1
		default_win_design
	}
	fn_wine_elf_query(){
		## Define bottle elf priority ans add necessary change accordingly. 
		if [ $wine_elf = 1 ]; then
			elf=64
		## Detected if the app is 32 or real 64, and change the Program Files detection accordingly.
			bin_target=$(find -L $user_prefix/$bottle_prefix/drive_c/Program\ {Files,Files\ \(x86\)} \
			-wholename "*$game_exe")
			_target=$?
			if [ $_target = 0 ]; then
				if [[ "$bin_target" =~ ^.*x86.*$ ]]; then
					root_key='Program Files (x86)/'
					elf_ext=' (x86)'
				else
					root_key="Program Files/"
					elf_ext=''
				fi
			fi
		else
			elf=32
			root_key="Program Files/"
			elf_ext=''
		fi
	}
	## at first launch for a botlle creation, sets the basics variables to access
	## custom path dirs and new Wine dirs
	fn_wine_basic_feed(){
		[[ $code_tag = 0 ]]|| echo -e "$g_notif\n>>>> start fn_wine_basic_feed ####\n$e_notif"
		## initial bottle set before launching main features
		# ';;/home/mike;;;wine.botlle;;/home/games/FFXIV/SquareEnix;;;TRUE;'
		unset basic_list
		ifs=$IFS
		IFS=$(echo -en "\n\b")
		basic_list=('user_prefix,3' 'bottle_prefix,6' 'game_path,8' 'wine_elf,11')
		basic_conf=$(cat $temp_b)
		## get back fn_wine_basic_feed data in case they come from an initial set. 
		for basic in ${basic_list[@]}; do
			unset basic_values
			basic_var=$(printf "$basic"|cut -d',' -f1)
			basic_rank=$(printf "$basic"|cut -d',' -f2)
			basic_val=$(printf "$basic_conf"| cut -d';' -f$basic_rank)
			if [[ $basic_val =~ ^[A-Z]+ ]]; then
				if [ $basic_val = 'TRUE' ]; then basic_val=1; else basic_val=0; fi
			fi
			if [ $basic_var = 'bottle_prefix' ]; then
				basic_val=.$basic_val
			fi
			basic_values=($basic_var=$basic_val)
			local "${basic_values}" 
		done
		
		## set default arch
		if [ $wine_elf = 1 ]; then winearch='win64'; else winearch='win32'; fi
		## set default env
		export WINEARCH=$winearch
		export WINEPREFIX="$user_prefix/$bottle_prefix"
		${wine_bin_path}wineboot -i
		fn_wine_elf_query
#		root_key="Program Files/"
		
		if [[ $game_path != '' && $game_path != $HOME ]]; then
			link=$(printf "$game_path"| sed -n "s/^.*\///g;p")
			ln -sf $game_path $user_prefix/$bottle_prefix/drive_c/$root_key
			game_dir=$user_prefix/$bottle_prefix/drive_c/$root_key$link
			game_exe=$user_prefix/$bottle_prefix/drive_c/$root_key$link
		else
			game_dir=$user_prefix/$bottle_prefix/drive_c/$root_key
			game_exe=$user_prefix/$bottle_prefix/drive_c/$root_key	
		fi
		IFS=$ifs
		fn_create_prefix

	}
	fn_wine_config(){
		[[ $code_tag = 0 ]]|| echo -e "$g_notif >>>> start fn_wine_config $e_notif"
		unset  basic_sets misc_sets def_args
		# check install elf type
		fn_wine_elf_query
#		root_key="Program Files/"
		# check already setted variables, if any.
		chk_arg_opts(){
#			ifs=$IFS
#			IFS=$(echo -en "\n\b")
			def_args=( $(cat $HOME/.winestarter/resources/options.list) )
			w_args_list=$(echo "$wine_opts"|tr '\ ' '\n')
			for val in ${def_args[@]}; do
				_arg=$(printf "$val"| cut -d';' -f1)
				_def=$(printf "$val"| cut -d';' -f2)
				if [ $(printf "$_arg"| egrep -c "[[:punct:]]") -gt 0 ]; then
					_short=$(printf "$_arg"| sed -nE "s/^.*[[:punct:]](\w*[a-z]$)/\1/p")
				else
					_short="$_arg"
				fi
				_var=("wine_arg_$_short")
				if [[ $_arg != misc ]]; then
					if [ $(echo "$wine_opts"| grep -Fc "$_arg") -gt 0 ]; then
						_def_arg='1'
						_rev_pat+=("$_arg")
					else
						_def_arg='0'
					fi
					## add field for each listed options in options.list
					# "23;$wine_arg_sdx;wine_arg_sdx;;$w_wine_cmd_sdx;CHK;;;"
					cmd_line_opts+=("$_def_arg;$_var;;$_def ($_arg);CHK;;")
					reconf_list+=("$_short;$_arg;$_var;$_def_arg")
				fi	
				if [[ $_arg == misc ]]; then
					## go back to default IFS temporarly.
					IFS=$ifs
					for _patt in $w_args_list; do
						sed_conv=$(echo "$_patt"| sed -n "s/^-//p")
						if [ $(echo -e "${_rev_pat[@]}"| egrep -c "$sed_conv") -eq 0 ]; then
							_arg_msc+=($_patt)
						fi
					done
					wine_arg_msc="\\$(echo "${_arg_msc[*]}")"
					if [ $(echo "$wine_arg_msc"| egrep -cx '^\\$') -eq 1 ]; then
						wine_arg_msc="unset"
					fi
					ifs=$IFS
					IFS=$(echo -en "\n\b")
				fi
			done
		}
		ifs=$IFS
		IFS=$(echo -en "\n\b")
		if [ $from_config = 1 ]; then
			if [[ $game_dir != '' ]]; then
				if [[ -d $user_prefix/$bottle_prefix/drive_c/$game_dir ]]; then
					game_dir="$user_prefix/$bottle_prefix/drive_c/$game_dir"
				else
					game_dir="$user_prefix/$bottle_prefix/drive_c/Program Files$elf_ext/$game_dir"
				fi
				game_exe="$game_dir/$game_exe"
			else
				if [[ -d $user_prefix/$bottle_prefix/drive_c/'Program Files'$elf_ext ]]; then
					game_dir=$user_prefix/$bottle_prefix/drive_c/'Program Files'$elf_ext
					game_exe=$game_dir
				else
					game_dir=$HOME
					game_exe=$game_dir
				fi
			fi
			if [[ $game_path == '' ]]; then game_path="$HOME/"; fi
			if [ $_extended = 1 ]; then chk_arg_opts; fi
			if ! [ $windowed ]; then windowed=1; fi
			if ! [ $cache_wipe ]; then cache_wipe=1; fi
			if ! [ $dbg_dialog ]; then dbg_dialog=0; fi
			if ! [ $dbg_handle ]; then dbg_handle=0; fi
		else
			app_portable='FALSE'
			special_cmd='FALSE'
			start_cmd='FALSE'
			windowed='TRUE'
			cache_wipe='TRUE'
			dbg_dialog='FALSE'
			dbg_handle='FALSE'
			w_config='TRUE'
			if ! [ -d $game_path ]; then game_path="$user_prefix"; fi
			if [ $_extended = 1 ]; then chk_arg_opts; fi
		fi
		
		## set the wine options files in resources and bottle
		export option_log=$user_prefix/$bottle_prefix/options.log
		export option_conf=$HOME/.winestarter/resources/options.list
		## tell to main script the last options conf modification time in EPOC at this point.
		if [[ -s $option_log ]]; then
			_option_log_pre=$(stat -c %Y $option_log )
		else
			_option_log_pre=$(date +%s)
		fi
		
		## button command
		control_panel="bash $bash_opt \"env WINEPREFIX=$user_prefix/$bottle_prefix $wine_bin control\""
		option_edit_cmd="bash $bash_opt \"edit_wine_options\""
		# window messages
		w_text="$bf Wine prefix$end
$vb\\Set wine prefix name, appli/game directories, etc.$end\\n
$nf\\Check here the sections you would like to configure.$end"
		## notes
		w_wine_elf_tip="$nf\\Note:$end The initial install is actually set to Wine $nf"$elf"Bits$end. If you would like a different install type, you need to create a new prefix."
		## env sets
		w_wine_user_prefix="$vb\\Set user prefix if not the user's default one:$end"
		w_wine_prefix="$vb\\Set the Wine Bottle prefix to use:$end"
		w_wine_prefix_tip="$nf\\\Ex:$end wine.my_bottle, no space and \"wine.\" suffix is mandatory."
		w_wine_game_path="$vb\\Set the full game/app path if different from bottle:$end"
		w_wine_game_dir="$vb\\Set full Wine style game/app directory:$end$vn (if already existing)$end"
		w_wine_game_exe="$vb\\Set the Wine game/app executable to launch:$end$vn (if already existing)$end"
		## excution type sets
		w_wine_option_ttl0="$bf\\Execution type options$end"
		w_wine_portable="$vb\\Set if the game/app is portable or you wish to install an already existing path to the C: drive root:$end"
		w_wine_game_spl="$vb\\Set if the app have to be started from the app directory:$end"
		## wine control panel
		w_wine_option_ttl1="$bf\\Wine control panel end user GUI$end"
		w_control_panel_tip="$vb\\Wine control panel can offer joystick calibration and some others cool stuffs, like apps removal and internet connection settings$end"
		## optional sets
		w_wine_option_ttl2="$bf\\Wine behaviour options$end"
		w_windowed_tip="$vb\\In practice, winecfg windowed mode at full screen usually give to games better performances. This is Winestarter default.$end"
		w_nocrash_tip="$vb\\Sometime Crash Dialog appears without avoid final app launch. Set the below option to prevent Crash Dialog to popup.$end"
		w_exceptionhandle_tip="$vb\\When app crash or wont exec, WineDebug prints a lot of line and mix app messages and Wine messages. To only catches exceptions handle by Wine and make debug a bit eaisier, set the below options.$end"
		w_cache_tip="$vb\\Some apps use a lot memory cache either on Linux or Windows, by default Winestarter allow to ask for memory cache wipe if it looks too high and can cause bad behaviour under the Wine layer. By the other hand, production data/web server could be affect by the cache wipe, so to use with cautions. Uncheck the option if you do not wish to allow this at all.$end"
		## extended sets
		w_wine_debugger="$bf\\WineDbg behaviour$end"
		w_wine_dbg_dlog="$vb\\In some case WineDbg crash dialog popups even if finally the managed app launch correctly. This option prevent the crash dialog to popup on working apps start.$end\n$nf\\Note:$end$vn It doesn't stop winedbg process, only GUI display.$end"
		w_wine_dbg_except="$vb\\WineDbg prints app and wine debug exceptions lines indifferently. When set, this option let application handles exceptions by itself, then WineDbg only catches exceptions that are not handled by the app and could make debbuging a bit easier.$end"
		w_wine_cmd="$bf\\Wine or app command line arguments$end"
		w_wine_cmd_tip="$vb\\You can set here Wine specific command line options. It can come from Wine by itself or specific from the app.$end"
		w_wine_cmd_gl="Force OpenGL only (opengl)"
		w_wine_cmd_sdx="Prevent Steam bottle sandboxing (no-cef-sandbox)"
		w_wine_cmd_msc="$nf Custom cmdline argument$end"
		w_wine_cmd_note="$nf\\Note$end: winestarter will keep all working user commandline options in its user directory for future possible use. If your custom option(s) is fully working, you could add it to the default menu with the button below."
		elf=$elf
		basic_sets="'';;;;LBL;;
'';;;$w_wine_elf_tip;LBL;;
'';;;;LBL;;
'';;;$w_wine_user_prefix;LBL;;
$user_prefix;user_prefix;;$nf Default Wine user prefix$end\t\t;DIR;;
'';;;$w_wine_prefix;LBL;;
$user_prefix/$bottle_prefix;bottle_prefix;;$nf Bottle prefix$end;CDIR;;
'';;;$w_wine_game_path;LBL;;
$game_path;game_path;;$nf Existing appli path$end;DIR;;
'';;;$w_wine_game_dir;LBL;;
$game_dir;game_dir;;$nf Full Wine appli directory$end;DIR;;
'';;;$w_wine_game_exe;LBL;;
$game_exe;game_exe;;$nf EXE file$end;FL;;
'';;;;LBL;;
'';;;$w_wine_option_ttl0;LBL;;
'';;;$w_wine_portable;LBL;;
$app_portable;app_portable;;Portable app (or to be set at C: drive root);CHK;;
'';;;$w_wine_game_spl;LBL;;
$special_cmd;special_cmd;;execute binary file inside the directory;CHK;;
$start_cmd;start_cmd;;execute binary from absolute path (using Wine \"start\" command);CHK;;
'';;;;LBL;;
'';;;$w_wine_option_ttl1;LBL;;
'';;;$w_control_panel_tip;LBL;;
$control_panel;cmd;;$vb click to launch Wine control Panel$end,$img_ctrlpanel_bt;FBTN;;
'';;;;LBL;;
'';;;$w_wine_option_ttl2;LBL;;
'';;;$w_windowed_tip;LBL;;
$windowed;windowed;;Set Wine to full windowed mode (dark background);CHK;;
'';;;$w_cache_tip;LBL;;	
$cache_wipe;cache_wipe;;Set memory cache wipe question popup at winestarter boot;CHK;;"
		## extended menu
		misc_sets="'';;;;LBL;;
'';;;$w_wine_debugger;LBL;;
'';;;$w_wine_dbg_dlog;LBL;;
$dbg_dialog;dbg_dialog;;Prevent crash dialog to popup;CHK;;
'';;;$w_wine_dbg_except;LBL;;
$dbg_handle;dbg_handle;;Exceptions handle by app only;CHK;;
'';;;;LBL;;
'';;;$w_wine_cmd;LBL;;
'';;;$w_wine_cmd_tip;LBL;;
${cmd_line_opts[*]}
$wine_arg_msc;wine_arg_msc;;$w_wine_cmd_msc;;;
'';;;$w_wine_cmd_note;LBL;;
$option_edit_cmd;cmd;;$vb click here to edit options menu$end,$img_wine_mod;FBTN;;"
		if [ $_extended = 1 ]; then
			basic_sets="${basic_sets[@]}
${misc_sets[@]}"
		fi
		item_sep=","
		## restore temporarly IFS
		IFS=$ifs
		## window style and function
		win_type=1
		## focused field
		focus=''
		[[ $code_tag = 0 ]]|| echo -e "$g_notif\n>>>> end fn_wine_config ####\n$e_notif"
		default_win_design
	}
	fn_wine_binary(){
		[[ $code_tag = 0 ]]|| echo -e "$g_notif\n>>>> start fn_wine_binary ####\n$e_notif"
		unset basic_sets track_list 
		w_wine_use_winepath="$vb Set if you want to use a custom Wine binary path:$end"
		w_wine_binary_title="$vb\\You can choose and activate here a custom Wine binary directory. Some apps (particulary old ones) could need old Wine versions. Datas are provided by PlayOnLinux and WineHQ Wine packagesserver.$end"
		w_wine_wine_path="$vb Set full path of customs Wine binaries repository:$end"
		w_wine_wine_ver="$vb Set the custom Wine directory name:$end"
		w_wine_dl_info="$vb\\Here, you can set the custom Wine binary package to download. You can choose between PlayOnLinux packages (for Wine older than 2.4) or WineHQ packages (above 2.4).$end"
#		w_wine_dl_note="$rb\\CAUTION:$end$vn Wine 3.x configured prefix can't be downgrade to Wine 2.x versions. If you wish to downgrade, you need to setup a new prefix.$end"
		w_wine_dl_warn="$rb\\WARNING:$end$vn Set one package only, otherwise, WineHQ Staging will be auto set.$end"
		w_wine_wine_pol="$vb Download a binary package from PlayOnLinux repo:$end"
		w_wine_wconfig="$vb\\When set, new Wine binary will setup new environment, this set will allow winecfg to start at boot:$end"
		w_text="$bf Configure an extra Wine binary path$end"
		## check already setted variables
		track_list=('use_winepath' 'wine_path' 'wine_ver' 'wine_pack')
		wineset_list=$track_list
#		wine_bin_cmd="bash $bash_opt \"select_wine_bin\""
#		wine_dis_cmd="bash $bash_opt \"select_wine_dis\""
#		wine_dis_cmd_dev="bash $bash_opt \"select_wine_dis_dev\""
		if [ $wine_elf = 1 ]; then dir_elf='amd64'; else dir_elf='x86'; fi
		if [ $from_config = 1 ]; then
			ifs=$IFS
			IFS=$(echo -en "\n\b")
			for trk_set in ${track_list[@]}; do
				eval trk_val='$'$trk_set
				case $trk_set in
					'use_winepath') [ $trk_val ]|| local $trk_set=0 ;;
					'wine_path') [[ $trk_val ]] || local $trk_set="$HOME/.winebin" ;;
					'wine_ver')
						if [[ $wine_ver =~ [0-9]{1,2}.[0-9]{1,2}.*$ ]]; then
							local $trk_set="$wine_path/$dir_elf/$wine_ver"
						else
							local $trk_set="$HOME/.winebin"
						fi
					;;
					'wine_pack') local $trk_set=$wine_pack ;;
					*) local $trk_set="$HOME/";;
				esac
			done
			IFS=$ifs
		else
			if ! [ -s $HOME/.winestarter/default-wine ]; then
				for trk_set in ${track_list[@]}; do
	#				unset local_set
					case $trk_set in
						'use_winepath') local $trk_set=0 ;;
						'wine_path'|'wine_ver') if [[ -d $HOME/.winebin ]]; then 
							local $trk_set="$HOME/.winebin"
						fi ;;
						*) local $trk_set="$HOME/" ;;
					esac
				done
			fi			
		fi
		eval _pol_list='$'_pol$elf'_list'
		export wine_path=$wine_path
		export wine_elf=$wine_elf
		ifs=$IFS
		IFS=$(echo -en "\n\b")
		basic_sets="'';;;;LBL;;
'';;;$w_wine_binary_title;LBL;;
$use_winepath;use_winepath;;use Wine binaries path (default:$HOME/.winebin);CHK;;
'';;;$w_wine_wine_path;LBL;;
$wine_path;wine_path;;$nf Wine binaries dir\t\t$end;DIR;;
'';;;$w_wine_wine_ver;LBL;;
$wine_ver;wine_ver;;$nf Wine bin name$end;DIR;;
'';;;;LBL;;
'';;;$w_wine_dl_info;LBL;;
'';;;$w_wine_dl_warn;LBL;;
unset#$_hq_stb0_list;_hq_stb0;;$vb WineHQ stable from 2.4 $end;CB;;
unset#$_hq_stg2_list;_hq_stg2;;$vb WineHQ staging from 3.3 $end;CB;;
unset#$_hq_stg0_list;_hq_stg0;;$vb WineHQ staging from 2.4 $end;CB;;
unset#$_hq_stg1_list;_hq_stg1;;$vb WineHQ staging to 2.4 $end;CB;;
unset#$_hq_dev0_list;_hq_dev0;;$vb WineHQ devel from 2.4 $end;CB;;
unset#$_pol_list;_pol_pkg;;$vb PoL Wine package to 1.8.6 $end;CB;;
'';;;;LBL;;
'';;;$w_wine_wconfig;LBL;;
$w_config;w_config;;Start Winecfg at app launch;CHK;;"
		[[ $code_tag = 0 ]]|| echo -e "$g_notif\n>>>> end fn_wine_binary ####\n$e_notif"
		IFS=$ifs
		item_sep="#"
		# window style and function
		win_type=1
		## focused field
		focus=''
		default_win_design
	}
	fn_regedit_config(){
		[[ $code_tag = 0 ]]|| echo -e "$g_notif\n>>>> start fn_regedit_config ####\n$e_notif"
		unset basic_sets misc_sets
		# config file preset
		nv_smi=$(find /usr/{bin,local/bin} -name nvidia-smi)
		if [[ -x $nv_smi ]]; then
			mem_set=$($nv_smi --query|grep -w "^.*Total.*[KMG]iB"|sed -n "s/^.*\ \([0-9]*\) [A-Z].*$/\1/;1p")
			x_mem='unset,'$mem_set
			mem_comment=$mem_set'Mo detected'
		else
			mem_set='unset'
			x_mem='unset'
			mem_comment=''
		fi
		vid_mem='128,256,512,768,1024,2048,3072,4096,6144'
		
		[[ $code_tag = 0 ]]|| echo -e "$g_notif >>>> detect previous registry $e_notif"
		reg_file=$(mktemp --tmpdir reg1.XXXXXXXX)
		reg_key='HKEY_CURRENT_USER'
		if [ $from_config = 1 ]; then
			if [ $(printf "$user_reg"| grep -c "\[.*\]") -gt 0 ]; then
				extract_reg=$(cat $config_file| sed -n "/^user_reg='/,/'/p"| perl -pe "s|\n|*|g"| \
				sed -E -n "s|^.*='(.*)'.*$|\1|;s|\*|\n|g;s|\\\|\\\\\\\|g;p")
			else
				extract_reg='[HKEY_CURRENT_USER\\Software\\Wine\\Direct3D]'
			fi
			echo -e "$extract_reg\n" > $reg_file
			export reg_file=$reg_file
			user_reg=$(awk 'NF' $reg_file | tr '\n' '*' | sed -n "s/.$//;s|\\\|\\\\\\\|g;s|*|\\\n|g;p")
		else
			printf "[HKEY_CURRENT_USER\\\\Software\\\\Wine\\\\Direct3D]*\\\"<option_name>\\\"=\\\"<option_set>\\\"*" > $reg_file
			user_reg=$(cat $reg_file| sed -n "s/.$//;s|\\\|\\\\\\\|g;s|*|\\\n|g;p")
		fi
		# convert temp reg file data in usable variables
		reg_values=('StrictDrawOrdering' 'csmt' 'DirectDrawRenderer' 'OffscreenRenderingMode' \
		'UseGLSL' 'CheckFloatConstants' 'VideoMemorySize' 'Nonpower2Mode' 'RenderTargetLockMode' )
#		edit_button="bash $bash_opt \"edit_reg_bin\""
		for reg_var in ${reg_values[@]}; do
			unset reg_variable
			if [[ -s $reg_file ]]; then
				if [ $(cat $reg_file| grep -c "$reg_var") -gt 0 ]; then
					## check for 'dword' reg file line structure and convert to 'enable/disable' for UI.
					if [ $(cat $reg_file| grep "$reg_var"| grep -c "dword") -eq 0 ]; then
						reg_val=$(cat $reg_file| grep "$reg_var"| \
						sed -n "s|^\"\($reg_var\)\"=\"\(.*\)\"|\2|p")
						## check for video memory reg value. Then, move 'unset' value if needed
						if [ $reg_var == 'VideoMemorySize' ]; then
							if [ $reg_val -gt 0 ]; then
								x_mem=$reg_val
								if [ $mem_set != $reg_val ]; then vid_mem="$mem_set,$vid_mem"; fi
							fi
						fi
					else
						reg_val=$(cat $reg_file| grep "$reg_var"| \
						sed -n "s|^\"\($reg_var\)\"=dword:\(.*\)|\2|p")
						if [[ $reg_val == '00000000' ]]; then
							reg_val=('disabled'); else reg_val="enabled"
						fi
					fi
					local $reg_var\_unset=',unset'
				else
					reg_val='unset'
					local $reg_var\_unset=''
				fi
			else
				reg_val='unset'
			fi
			reg_variable+=($reg_var=$reg_val)
			local $reg_variable
		done
		if [ $_extended = 1 ]; then
			[[ $code_tag = 0 ]]|| echo -e "$g_notif >>>> start extended features $e_notif"
			if [[ -s $HOME/.winestarter/resources/mime-preset.lst ]]; then
				res_mime_preset=$(cat $HOME/.winestarter/resources/mime-preset.lst| tr '\n' ','| \
				sed -n "s/,$//p")
			fi
			reg_log=$user_prefix/$bottle_prefix/dlls_reg.log
			if [[ -s $reg_log ]]; then
				unset dlls_var_list
				dll_base_list=("$(cat $reg_log| cut -d',' -f2)")				
				for dll_base in ${dll_base_list[@]}; do
					if [ $elf = 32 ]; then
						sys_elf='32'
						reg_field_list+=( "$dll_base" )
					else
						sys_elf='32/64'
						if [ $(echo "${reg_field_list[*]}"| egrep -c "$dll_base" ) -eq 0 ]; then
								reg_field_list+=( "$dll_base" )
						fi
					fi
				done
				reg_dlls_field=$(echo "${reg_field_list[*]}"| sed -n "s/\ /\, /g;p")
				reg_dll_msg="$vb\\Registered DLLs ($sys_elf):$end"
				dlls_var_list=( "'';;;$reg_dll_msg $reg_dlls_field;LBL;;" )
			fi
		fi
			
		# window messages
		w_text="$bf Edit the Wine registry$end\\n\
$vb\\Set here the most usual registry Direct3D graphic options$end\\n\
$vb\\or edit a file manualy (will be merge with others sets)$end" #\\n \
		w_reg_manual0="$rb\\WARNNG:$end$vn Direct3D registry config is only usable under WindowsXP bottle$end"
		w_reg_manual1="$vb Custom Direct3D registering (manual edit).$end"
		w_reg_manual2="$rb\\WARNING:$end$vn Don't remove lines set with the menu above, they will be kept anyway.$end"
		w_reg_manual3="$bf\\Unusual registry commands and options$end"

		w_reg_2_title="$bf\\Associate mime type to local system$end"
		w_reg_2_tip0="$vb\\In many case, user must install subsidiary software to run some file type directly from the bottle (avi, mp4, txt, doc, etc). You can set here those files types to be launch by your local system apps.$end"

		w_reg_2_warn0="$vn\\Files will be open with default xdg-open environment set$end"
		w_reg_2_setted="$vb\\Already associated:$end $(printf "$local_association"| sed -n 's/,/, /g;p')"
		w_reg_2_set_tip0="$vb\\Use presets or edit manually$end:$vn (will be added to presets)$end"
		w_reg_2_set_tip1="$rb\\WARNING$end$vn : When picked up from a directory, files types need to be of the same kind (mp4, avi or doc, odf, etc), this is mandatory.$end"
		w_reg_2_set_1="$nf Select one or more files for type$end"
		w_reg_2_set_2="$nf or pick a preset in the list$end"
		w_reg_2_set_4="Set local program to use"

		w_reg_3_tip0="$vb\\In some cases, it could be necessary to use specific system reg file, DLLs registration/unregistration to set properly a bottle.$end"
		w_reg_3_warn0="$rb\\WARNING$end$vn: Doing something nasty here can strongly compromise your bottle.$end"
		w_reg_3_titl0="$vb\\Register, unregister specific DLLs:$end"
		w_reg_3_cmd0="$nf Select the operation class$end"
		w_reg_3_cmd1="$nf Select the system type$end"
		w_reg_3_cmd2="$nf Select the DLL (one or more)$end"
		w_reg_3_tit1e="$vb\\Create a specific reg file$end"
		w_reg_3_cmd3="$nf Select the type$end"
		w_reg_3_cmd4="$vb\\Write the custom registration without the key line$end"
		w_reg_3_tip=""
		
		w_reg_def_SDO="$nf StrictDrawOrdering$end$vn\tbelow Wine 2.6$end"
		w_reg_def_CSMT="$nf CSMT$end$vn \t\t\t\tWine 2.6 and above$end"
#		w_reg_def_VID="$nf VideoMemorySize$end$vn     unset to not use$end"
		w_reg_def_VID="$nf VideoMemorySize$end$vn  $mem_comment$end"
#		w_reg_def_=""
#		w_reg_def_=""
		w_reg_launch="Click to launch regedit GUI separatly"
		reg_action="bash $bash_opt \"env WINEPREFIX=$user_prefix/$bottle_prefix $wine_bin regedit &>/dev/null\""

		basic_sets="'';;;;LBL;;
'';;;$w_reg_manual0;LBL;;
$StrictDrawOrdering,enabled,disabled$StrictDrawOrdering_unset;StrictDrawOrdering;;$w_reg_def_SDO;CB;;
$csmt,enabled,disabled$csmt_unset;csmt;;$w_reg_def_CSMT;CB;;
$DirectDrawRenderer,opengl,gdi$DirectDrawRenderer_unset;DirectDrawRenderer;;$nf DirectDrawRenderer$end;CB;;
$OffscreenRenderingMode,backbuffer,fbo$OffscreenRenderingMode_unset;OffscreenRenderingMode;;$nf OffscreenRenderingMode$end;CB;;
$RenderTargetLockMode,auto,disabled,readdraw,readtex,texdraw,textex$RenderTargetLockMode_unset;RenderTargetLockMode;;$nf RenderTargetLockMode$end;CB;;
$UseGLSL,enabled,disabled$UseGLSL_unset;UseGLSL;;$nf UseGLSL$end;CB;;
$CheckFloatConstants,enabled,disabled$CheckFloatConstants_unset;CheckFloatConstants;;$nf CheckFloatConstants$end;CB;;
$Nonpower2Mode,repack;Nonpower2Mode$Nonpower2Mode_unset;;$nf Nonpower2Mode$end;CB;;
$x_mem,$vid_mem$VideoMemorySize_unset;VideoMemorySize;;$w_reg_def_VID;CBE;;
'';;;$w_reg_manual1;LBL;;
$user_reg;user_reg;;$w_reg_manual2;TXT;;
$reg_action;;;$w_reg_launch,$img_reg_bt;FBTN;;"

		misc_sets="'';;;;LBL;;
'';;;$w_reg_2_title;LBL;;
'';;;$w_reg_2_tip0;LBL;;
'';;;$w_reg_2_warn0;LBL;;
'';;;$w_reg_2_set_tip1;LBL;;
'';;;$w_reg_2_set_tip0;LBL;;
'';;;$w_reg_2_setted;LBL;;
unset;Selected_Files;;$w_reg_2_set_1;MFL;;
unset,$res_mime_preset;mime_preset;;$w_reg_2_set_2;CB;;
'';;;;LBL;;
'';;;$w_reg_manual3;LBL;;
'';;;$w_reg_3_tip0;LBL;;
'';;;$w_reg_3_warn0;LBL;;
'';;;;LBL;;
'';;;$w_reg_3_titl0;LBL;;
${dlls_var_list[@]}
unset,register,unregister;dll_reg_type;;$w_reg_3_cmd0;CB;;
unset,wine32,wine64,both;dll_elf_type;;$w_reg_3_cmd1;CB;;
$user_prefix/$bottle_prefix/drive_c/windows;dll_file_list;;$w_reg_3_cmd2;MFL;;"
#		'';;;;LBL;;
#		'';;;$w_reg_3_title;LBL;;
#		unset,user,system;misc_reg_type;;$w_reg_3_cmd3;CB;;
#		;misc_reg_val;;$w_reg_3_cmd4;TXT;;"
#		${previous_reg_edit[@]}
#		$edit_button;user_reg;;$w_reg_manual1;FBTN;;"

		if [ $_extended = 1 ]; then
			basic_sets="${basic_sets[@]}
${misc_sets[@]}"
		fi
		[[ $code_tag = 0 ]]|| echo -e "$g_notif\n>>>> end fn_regedit_config ####\n$e_notif"
		item_sep=","
		# start form display
		win_type=1
		## focused field
		focus=''
		default_win_design
		# create main window variables
	}
	fn_make_tricks_menu(){
		[[ $code_tag = 0 ]]|| echo -e "$g_notif\n>>>> start fn_make_tricks_menu$e_notif"
		prim_file=$(mktemp --tmpdir trk1.XXXXXXXX)
		sec_file=$(mktemp --tmpdir trk2.XXXXXXXX)
		menu_file=$(mktemp --tmpdir trk3.XXXXXXXX)
		menu_conf=$(mktemp --tmpdir trk4.XXXXXXXX)
		
		unset prim_keywords sec_keywords
		
		## interpret temp file and create auto field for yad
#		wtricks_list=$HOME/.winestarter/resources/wtricks_dlls.list
#		wtricks_conf=$HOME/.winestarter/resources/wtricks_dlls.conf

#		if ! [ -e $wtricks_list ]; then touch $wtricks_list; fi
		## get a full regex of the winetricks dlls list output; then recompose later for good usage. 
		regex='(.*[0-9a-z])(\s*[\ ]{3,})(\w*[[:alnum:]].*)\ \((\w+.*), ([0-9]{4}|[0-9]{4}-[0-9]{4})\) \[((.*),(.*)|(.*))\]'
		prim_keywords=(
			"Microsoft,Most common Microsoft dlls packages (often mandatory):,1"
			"Nvidia,PHYSX Nvidia package: can be very useful to improve performances,0"
			"Adobe,Adobe softwares and plugins packages,0"
			"Apple,Apple softwares and plugins packages,0"
			"other,Other useful packages,0")
		sec_keywords=(
			"d3dx;Direct3D packages\$rb ( DX11 only available for Win7 and above)\$end"
			"xact;Xact is mostly needed for Direct3D 9 packages"
			"gdi;GDI+, core Graphic Device Interface rendering"
			"msxml;Microsoft XML Core Services"
			"dotnet;NET packages for Wine Mono replacement"
			"mfc;MS Foundation Class (mfc), often called by Visual C++ apps"
			"vcrun;Visual C++ runtime libraries (vcrun)"
			"vb[0-9]run;Visual Basic runtime libraries (vbrun)"
			"ie[0-9];IE packs in case GECKO mozilla package failed to load HTML pages"
			"rich;RichEdit Control"
			"other;Other Microsoft dlls")
		ifs=$IFS
		IFS=$(echo -en "\n\b")
		echo "basic_sets=\"" > $menu_conf 
		echo "'';;;\$w_tricks_ald_list;LBL;;
'';;;\$w_tricks_cache;LBL;;
'';;;;LBL;;" > $menu_file
#		real_n='3'
		sed -ni "s/;/:/i;p" $w_tricks_dlls
		if [ $(cat $w_tricks_dlls| grep -wc "(.*,.*,.*,.*,.*).*(.*)") -gt 0 ]; then
			trk_recompose=$(cat $w_tricks_dlls| grep -w "(.*,.*,.*,.*,.*).*(.*)"| awk '{print $1}')
			for _recompose in ${trk_recompose}; do
				sed -ni "s/\($_recompose[ ]\+\) \(.*\) \((.*)\)\(.*\)\((.*)\)\(.*\)/\1 \2\4\5\6/i;p" \
				$w_tricks_dlls
			done
		fi
		## first isolate each part by keyword	
		for _all in ${prim_keywords[@]}; do
			_prim_key=$(printf "$_all"| cut -d',' -f1)
			_prim_tip=$(printf "$_all"| cut -d',' -f2)
			_sec_key=$(printf "$_all"| cut -d',' -f3)
			printf "'';;;#$_prim_tip;LBL;;\n" >>$menu_file
			## if keyword has secondary keywords
			if [ $_sec_key -gt 0 ]; then
				## decompose primary list to get secondary keywords
				for _sec in ${sec_keywords[@]}; do
					cat $w_tricks_dlls| grep -F "$_prim_key" > $prim_file
					_sec_key=$(printf "$_sec"| cut -d';' -f1)
					_sec_desc=$(printf "$_sec"| cut -d';' -f2)
					printf "'';;;#$_sec_desc;LBL;;\n" >>$menu_file
					if [[ $rev_key != '' ]]; then _sec_rev='|'$_sec_key; else _sec_rev=$_sec_key; fi
					rev_key="$rev_key$_sec_rev"
					if [[ $_sec_key == other ]]; then
						cat $prim_file | egrep -v "\s*($rev_key)" > $sec_file
					else
						cat $prim_file | egrep "\s*^$_sec_key" > $sec_file
					fi
					compo_file=$sec_file
					cat $compo_file| sed -E -n "s/$regex/\$\1;\1;; \3 (\1, \5)\8;CHK;;/p" \
					>> $menu_file
				done
			else
				if [[ $_prim_key == other ]]; then
					cat $w_tricks_dlls | egrep -v "\s*($rev_prim)" > $prim_file
					_prim_key=''
				else
					cat $w_tricks_dlls | egrep "\s*$_prim_key" > $prim_file
				fi
				compo_file=$prim_file
				cat $compo_file| sed -E -n "s/$regex/\$\1;\1;; \3 (\1, \5)\8;CHK;;\1/p" \
				>> $menu_file
			fi
			if [[ $rev_prim != '' ]]; then _prim_rev='|'$_prim_key; else _prim_rev=$_prim_key; fi
			rev_prim="$rev_prim$_prim_rev"
		done
		
		echo "'';;;;LBL;;
'';;;\$w_tricks_winetricks;LBL;;
\$trk_action;;;\$w_tricks_trk_launch,\$img_tricks_bt;FBTN;;" >> $menu_file
		cat $menu_file >> $menu_conf
		## Insert span values in description fields
		sed -E -ni "s/^(.*;;;)#(\w*[A-Z].*)(;LBL)(.*)$/\1\$vb\\\\\\\\\\2\$end\3\4/i;p" \
		$menu_conf
		if [ $(cat $menu_conf| grep -Fc "cached") -gt 0 ]; then
			sed -E -ni "s/cached/*/gi;p" $menu_conf
		fi
		echo "\"" >> $menu_conf
		
		IFS=$ifs
		[[ $code_tag = 0 ]]|| echo -e "$g_notif\n>>>> end fn_make_tricks_menu $e_notif"
	}
	fn_winetricks(){
		[[ $code_tag = 0 ]]|| echo -e "$g_notif\n>>>> start fn_winetricks $e_notif"
		unset basic_sets track_list track_sets conf_dat
		unset prim_keywords sec_keywords
		w_tricks_dlls=$HOME/.winestarter/resources/tricks_dlls.txt
		
		track_list=$(cat "$w_tricks_dlls"| awk '{print $1}')
		winetricks_log=$user_prefix/$bottle_prefix/winetricks.log
		if [ $from_config = 1 ]; then
			if [[ -s $winetricks_log ]]; then
				tricks_log=$(mktemp --tmpdir tricks.XXXXXXXX)
				w_tricks_reserve=$scpt_dir/resources/tricks_workaround.txt
				w_filters=$(cat $w_tricks_reserve| tr '\n' '|')'w_workaround'
				cat $winetricks_log| egrep -v "$w_filters" >$tricks_log
				track_sets=$(cat $tricks_log| tr '\n' ' ')
			else
				track_sets=$(printf "$w_tricks_list"|sed -n "s/^.*=\"//;s/\"$//g;p"|tr ',' '\ ')
			fi
		fi
		for trk_set in ${track_list[@]}; do
			if [ $from_config = 1 ]; then
				trk_box=$(printf "${track_sets[@]}"| egrep -wc "\s*$trk_set")
			else
				trk_box=0
			fi
			conf_dat+=("$trk_set=$trk_box")
		done
		# create a list including extra install dlls from winetricks list
		if [ $from_config = 1 ]; then
			for trk_var in ${track_sets[@]}; do
				if [ $(printf "${track_list}"| grep -c "$trk_var") -eq 0 ];then
				extra_sets+=("$trk_var")
				fi
			done
		fi
		local "${conf_dat[@]}"
		# display already installed packages
		if [ $(printf "$w_tricks_list"| grep -c .) -gt 0 ]; then
			if [[ -s $tricks_log && $(cat $tricks_log| grep -c .) -gt 0 ]]; then
				already_there=$(cat $tricks_log| tr '\n' '*'| sed -n "s/[*]\{1,2\}$//;s/*/, /g;p")
			else
				already_there=$(echo "$w_tricks_list"| sed -n "s/,/, /g;p")
			fi
		else
			already_there='none'
		fi
		# window messages
		w_text="$bf Winetricks common apps and DLLs$end\\n$vb\\Set the most common Windows packages available in Winetricks needed by your app.$end"
		w_tricks_alt_dot4_tip="$nf\\Note$end: .NET 4.x need an extra additional packges for clean install. Follow Winetrciks instruction during install without stopping the process."
		w_tricks_winetricks="$bf More from Winetricks$end"
		w_tricks_trk_launch="$vb Click to launch Winetricks separatly$end"
		w_tricks_trk_dll="$vb\\or launch Winetricks$end $nf(one or more packages)$end"
		w_tricks_trk_dlls="$vb Add an additional DLL component$end"
		w_tricks_ald_list="$vb\\Already installed:$end $already_there"
		w_tricks_cache="$nf\\Note:$end All packeges marked with a \* are already cached."
		fn_make_tricks_menu
		ifs=$IFS
		IFS=$(echo -en "\n\b")
		# var list sets
		trk_action="bash $bash_opt \"$w_tricks_bin --gui &>/dev/null\""
		. $menu_conf
		[[ $code_tag = 0 ]]|| echo -e "$g_notif\n>>>> end fn_winetricks ####\n$e_notif"
		IFS=$ifs
		item_sep=","
		# start form display
		win_type=1
		## focused field
		focus=''
#		exit 0
		default_win_design
		# window style and function
	}
	fn_install_soft(){
		[[ $code_tag = 0 ]]|| echo -e "$g_notif\n>>>> start fn_install_soft ####\n$e_notif"
		unset  basic_sets misc_sets track_list
		
		pkgs_log=$user_prefix/$bottle_prefix/packages.log
		extra_log=$user_prefix/$bottle_prefix/extra_pcks.log
		track_list=('w_install_exe' 'w_exe_path' 'w_tricks_opts' 'w_more_pkgs' 'w_install_zip' 'w_install_dir' 'w_download_dir' 'w_extra_script')

		for _var in ${track_list[@]}; do
			eval _listed='$'$_var
			case $_var in
				'w_install_exe') w_install_exe=0 ;;
				'w_tricks_opts') if [[ $_listed != '' ]]; then local $_var=1; else local $_var=0; fi ;;
				'w_exe_path') if [[ -s $pkgs_log ]]; then
						exe_log=$(cat $pkgs_log| tr '\n' ','| sed -n "s/,$//p")
						if [ $(cat $pkgs_log| grep -c "$_listed") -gt 0 ]; then _listed="$HOME/"; fi
					else
						exe_log='none'
						if ! [[ $_listed ]]; then _listed="$HOME/"; fi
					fi
					local $_var="$_listed" ;;
				'w_more_pkgs')
					if [[ $_listed ]]; then
						if [ $(cat $config_file| sed -n "/^w_more_pkgs/,/'$/p"| grep -c . ) -gt 1 ]; then
							_listed=$(cat $config_file| sed -n "/^w_more_pkgs/,/'$/p"| tr '\n' ','| \
							sed -En "s/^.*='(.*)',/\1/p")
						fi
					fi
					if [[ -s $extra_log ]]; then
						more_log=$(cat $extra_log| tr '\n' ',')
						if [[ $_listed ]]; then
							more_list=( $(echo -e "$_listed"| tr ',' '\n') )
							for _more in ${more_list[*]}; do
								if [ $(cat $extra_log| grep -c "$_more") -eq 0 ]; then
									_mod_list+=("$_more,")
								fi
							done
							_listed=$(echo "${_mod_list[@]}"| sed -n "s/,$//g;p")
						else
							_listed="$HOME/"
						fi
					else
						more_log='none'
						if ! [[ $_listed ]]; then _listed="$HOME/"; fi
					fi
					local $_var="$_listed" ;;
				'w_download_dir') local $_var=$XDG_DOWNLOAD_DIR/ ;;
				*) local $_var="$HOME/" ;;
			esac
		done
		
		# window messages
		w_text="$bf\\Software install$end\\n\
$vb\\This feature allow you to install a software at WineStarter launch$end\\n\
$vb\\It will work in most cases, but could fail before the end of process$end\n\
$nf\\TIP:$end For downloading, you can replace file name path by internet URL."
		w_tricks_trk_exe="check here to activate install process"
		w_tricks_ins_exe="$nf Select the .exe/.msi package to install$end"
		w_tricks_trk_opt="$vb Winetricks command line options:$end"
		w_tricks_trk_opt0="option (--no-isolate): force Winetricks to not create its own prefix"
		w_tricks_trk_tip0="$vb\\User prefix and wine bottle have to be already set in Wine tab.$end"
		w_tricks_trk_tip1="$nf\\Note:$end Steam Winetricks package is usualy broken, download it by your own if needed."
		w_tricks_info0="$nf\\Already installed:$end $exe_log."
		w_tricks_info1="$nf\\Already installed:$end $more_log."
		w_more_pkgs0="$bf\\More packages$end"
		w_more_pkgs1="$vb\\If you have to install associated package or other dlls from separate source and not available in Winetricks, select them here$end"
		w_more_pkgs2="$nf Select one or more$end"
#		w_more_pkgs3="$rb\\WARNING$end:$nf Set if the application is full 64 bits$end"
		w_more_zip0="$bf\\Alternative install type$end"
		w_more_zip1="$vb\\In some cases, install is provided by a compressed file (zip, rar, 7z, exe) extracted or to extract directly to the bottle Program File directory. Manage them here.$end"
		w_more_zip2="$nf\\Note$end: for auto-extractible exe file, create the directory first. Name with a '$nf-$end' after the first word will be auto-detected."
		w_more_zip3="$nf Select the compressed file to install$end"
		w_more_zip4="$nf Select or create the target directory$end"
		w_more_dl0="$bf\\Download directory option$end"
		w_more_dl1="$vb\\By default, download will be stored in user default dowload directory. You can set a different one here.$end"
		w_more_dl2="$nf Select dowload directory$end"
		w_more_scpt0="$bf\\User script$end"
		w_more_scpt1="$vb\\In very rare case, some users wish to add script to their app directory (updator,log collector, etc), this is the place to do so.$end"
		w_more_scpt2="$rb\\WARNING$end:$nf Choose wisely, this is at your own risk.$end"
		w_more_scpt3="$nf Select a script (bash, python, etc) $end"
			
		pre_list=0
		# var list sets
		basic_sets="'';;;;LBL;;
$w_install_exe;w_install_exe;;$w_tricks_trk_exe;CHK;;
'';;;;LBL;;
'';;;$w_tricks_info0;LBL;;
$w_exe_path;w_exe_path;;$w_tricks_ins_exe;MFL;;_w_soft
'';;;;LBL;;
'';;;$w_tricks_trk_opt;LBL;;
$w_tricks_opts;w_tricks_opts;;$w_tricks_trk_opt0;CHK;;
'';;;;LBL;;
'';;;$w_more_pkgs0;LBL;;
'';;;$w_more_pkgs1;LBL;;
'';;;$w_tricks_info1;LBL;;
$w_more_pkgs;w_more_pkgs;;$w_more_pkgs2;MFL;;
'';;;;LBL;;
'';;;$w_more_zip0;LBL;;
'';;;$w_more_zip1;LBL;;
'';;;$w_more_zip2;LBL;;
$w_install_zip;w_install_zip;;$w_more_zip3;MFL;;
$w_install_dir;w_install_dir;;$w_more_zip4;CDIR;;
'';;;;LBL;;
'';;;$w_more_dl0;LBL;;
'';;;$w_more_dl1;LBL;;
$w_download_dir;w_download_dir;;$w_more_dl2;CDIR;;"

		misc_sets="'';;;;LBL;;
'';;;$w_more_scpt0;LBL;;
'';;;$w_more_scpt1;LBL;;
'';;;$w_more_scpt2;LBL;;
$w_extra_script;w_extra_script;;$w_more_scpt3;FL;;"
		if [ $_extended = 1 ]; then
		basic_sets="${basic_sets[@]}
${misc_sets[@]}"
		fi
	[[ $code_tag = 0 ]]|| 	echo -e "$g_notif\n>>>> end fn_install_soft ####\n$e_notif"
		item_sep=","
		# start form display
		win_type=1
		## focused field
		focus=''
		default_win_design
		# window style and function
	}
	fn_nvidia_config_1(){
		[[ $code_tag = 0 ]]|| echo -e "$g_notif\n>>>> start fn_nvidia_config_1 ####\n$e_notif"
		unset basic_sets track_list #
		# window messages
		w_nv_tip0="$vb All variable are unset by default. (0) mean 'off' (1) means 'on'.$end"
		w_nv_fsaamod0="$vb Full Scene Anti Aliasing, from 0 (off) to 5 (16x) : (1) 2x (2xMS), (2) 4x (4xMS), (3) 8x (4xSS/2xMS), (4) 8x (8xMS), (5) 16x (4xSS/4xMS)$end"
		w_nv_fsaactrl0="$vb If set, FSAA comes with 2 others arguments:$end"
		w_nv_fsaactrl1="$nf Full controlled, enhanced if using multisample or ignored (manage by nvidia-setting)$end"
		w_nv_fxaa0="$vb This will allow (not force) Fast Approximate Antialiasing: multisampling and supersampling methods$end"
		w_nv_aniso="$vb Anisotropic texture filtering set: off (0), x2 (1), x4 (2), x8 (3), x16 (4)$end"
		w_nv_vblank="$vb Synchronize vertical diplay refresh$end"
		w_nv_thread="$vb Libpthread is not usualy enable in Wine, you can force it to prelaod$end"
		w_nv_perf="$vb Performance can be set between Quality(1), Mixed(2) Performance(3)$end"

		# check already setted variables
		if [ $from_config = 1 ]; then
			if [ $__GL_FSAA_MODE -gt 0 ]; then
				case $__GL_FSAA_MODE in
					'5') __GL_FSAA_MODE=2;;
					'9') __GL_FSAA_MODE=3;;
					'10') __GL_FSAA_MODE=4;;
					'11') __GL_FSAA_MODE=5;;
				esac
				if [ $__GL_FSAAAppControlled = 0 ]&&[ $__GL_FSAAAppEnhanced = 0 ]; then
					__GL_FSAA_CTRL='full control'
				elif [ $__GL_FSAAAppControlled = 0 ]&&[ $__GL_FSAAAppEnhanced = 1 ]; then
					__GL_FSAA_CTRL='enhanced'
				elif [ $__GL_FSAAAppControlled = 1 ]&&[ $__GL_FSAAAppEnhanced = 1 ]; then
					__GL_FSAA_CTRL='ignored'
				else
					__GL_FSAA_CTRL='unset'
				fi
			else
				__GL_FSAA_CTRL='unset'
			fi
		else
			__GL_FSAA_CTRL='unset'
		fi
		
		track_list=(
		"__GL_FSAA_MODE"
		"__GL_ALLOW_FXAA_USAGE"
		"__GL_LOG_MAX_ANISO"
		"__GL_SYNC_TO_VBLANK"
		"__GL_THREADED_OPTIMIZATIONS"
		"__GL_OpenGLImageSettings")
		for trk_set in ${track_list[@]}; do
			eval trk_field='$'$trk_set
			if [[ $trk_field == '' ]]; then
				local $trk_set='unset'
			fi
		done
		# var list sets
		w_title="Wine Start Config"
		w_text="$bf Configure Nvidia OpenGL options$end"
		basic_sets="'';;;$w_nv_tip0;LBL;;
'';;;;LBL;;
'';;;$w_nv_fsaamod0;LBL;;
$__GL_FSAA_MODE,0..5;__GL_FSAA_MODE;;$nf Full scene antialiasing$end;NUM;;
'';;;$w_nv_fsaactrl0;LBL;;
'';;;$w_nv_fsaactrl1;LBL;;
$__GL_FSAA_CTRL,full control,enhanced,ignored;__GL_FSAAA_CTRL;;$nf FSAA control type$end;CB;;
'';;;$w_nv_fxaa0;LBL;;
$__GL_ALLOW_FXAA_USAGE,0,1;__GL_ALLOW_FXAA_USAGE;;$nf Fast approximate antialiasing (FXAA)\t$end;CB;;
'';;;$w_nv_aniso;LBL;;
$__GL_LOG_MAX_ANISO,0..4;__GL_LOG_MAX_ANISO;;$nf Anisotropic texture filtering$end;NUM;;
'';;;$w_nv_vblank;LBL;;
$__GL_SYNC_TO_VBLANK,0,1;__GL_SYNC_TO_VBLANK;;$nf Sync to VBLANK$end;CB;;
'';;;$w_nv_thread;LBL;;
$__GL_THREADED_OPTIMIZATIONS,0,1;__GL_THREADED_OPTIMIZATIONS;;$nf Preload libpthread$end;CB;;
'';;;$w_nv_perf;LBL;;
$__GL_OpenGLImageSettings,1,2,3;__GL_OpenGLImageSettings;;$nf Nvidia graphic Performance set$end;CB;;"
		[[ $code_tag = 0 ]]|| echo -e "$g_notif\n>>>> end fn_nvidia_config_1 ####\n$e_notif"
		
		item_sep=","
		# start form display
		win_type=1
		## focused field
		focus=''
		default_win_design
		# window style and function
	}
	fn_nvidia_config_2(){
		[[ $code_tag = 0 ]]|| echo -e "$g_notif\n>>>> start fn_nvidia_config_2 ####\n$e_notif"
		unset basic_sets track_list  #
		# window messages
		w_nv_tip0="$vb All variable are unset by default. (0) mean 'off' (1) means 'on'.$end"
		w_nv_display="$vb VBLANK can't bet set separatly when using multi screen, choose one here if needed:$end"
		w_nv_fbconfig="$vb This set the X server FBconfig behaviour (very optional):$end"
		w_nv_yield0="$vb Updating window moves yield: can be useful if some window has refresh issues:$end"
		w_nv_yield1="$nf normal yield (''), no yield (NOTHING), background (USLEEP)$end"
		w_nv_unofficial0="$vb Allow unofficial GLX implementation from appli (very optional):$end"
		w_nv_gsync="$vb If monitor can manage G-SYNC behaviour, this option could improve performance:$end"
		w_nv_glsl0="$vb This option permit to recompile GLSL and could be useful if appli is missing some extension in OpenGL sets:$end"
		# use 'get_xrandr_list' to set the connected monitor list.
		monitors_list=$(printf "${connect_[@]}"|tr '\n' '#')
		# check already setted variables
		track_list=(
		"__GL_SYNC_DISPLAY_DEVICE"
		"__GL_SORT_FBCONFIGS"
		"__GL_YIELD"
		"__GL_ALLOW_UNOFFICIAL_PROTOCOL"
		"__GL_GSYNC_ALLOWED"
		"__GL_IGNORE_GLSL_EXT_REQS")
		for trk_set in ${track_list[@]}; do
			eval trk_field='$'$trk_set
			if [[ $trk_field == '' ]]; then
				local $trk_set='unset'
			fi	
		done
		# var list sets
		w_title="Wine Start Config"
		w_text="$bf Configure extended Nvidia display options$end"
		basic_sets="'';;;$w_nv_tip0;LBL;;
'';;;;LBL;;
'';;;$w_nv_display;LBL;;
$__GL_SYNC_DISPLAY_DEVICE,$monitors_list;__GL_SYNC_DISPLAY_DEVICE;;$nf VSync display$end;CB;;
'';;;$w_nv_fbconfig;LBL;;
$__GL_SORT_FBCONFIGS,0,1;__GL_SORT_FBCONFIGS;;$nf Xorg FBconfig$end;CB;;
'';;;$w_nv_yield0;LBL;;
'';;;$w_nv_yield1;LBL;;
$__GL_YIELD,normal,NOTHING,USLEEP;__GL_YIELD;;$nf Window yield:$end;CB;;
'';;;$w_nv_unofficial0;LBL;;
$__GL_ALLOW_UNOFFICIAL_PROTOCOL,0,1;__GL_ALLOW_UNOFFICIAL_PROTOCOL;;$nf Unofficial OpenGL implementation$end\t\t\t;CB;;
'';;;$w_nv_gsync;LBL;;
$__GL_GSYNC_ALLOWED,0,1;__GL_GSYNC_ALLOWED;;$nf G-Sync$end;CB;;
'';;;$w_nv_glsl0;LBL;;
$__GL_IGNORE_GLSL_EXT_REQS,0,1;__GL_IGNORE_GLSL_EXT_REQS;;$nf Ignore GLGS extension check$end;CB;;"
		[[ $code_tag = 0 ]]|| echo -e "$g_notif\n>>>> end fn_nvidia_config_2 ####\n$e_notif"
		
		item_sep=","
		# start form display
		win_type=1
		## focused field
		focus=''
		default_win_design
		# window style and function
	}
	# base display auto-detection scripts
	get_xrandr_list(){
			[[ $code_tag = 0 ]]|| echo -e "$g_notif >>>> get_xrandr_list$e_notif"
			unset display_ connect_ dsp_vars dsp_res_ dsp_res_list
			ifs=$IFS
			IFS=$(echo -en "\n\b")
			# give the list of connected monitors with all details
			connected_list=$(xrandr --current| grep "connected"|grep -v "disconnected")
			# give the actual primery resolution 
			current_res=$(xrandr --current| fgrep "*"| awk '{print $1}')
			n=0
			# dispatch display list in variables
			for dsp0 in ${connected_list[@]}; do
				# monitors system name
				_dsp=$(printf "$dsp0"| awk '{print $1}')
				# detect if it is primary or not
				_prm=$(printf "$dsp0"| grep -c "primary")
				# give the actual monitor resolution
				_def=$(printf "$dsp0"| grep -o "\(\w*[0-9]\{3,4\}[x]\w*[0-9]\{3,4\}\)")
				# set each monitor as variable
				display_+=("DSP_$n=$_dsp")
				# set a usable list of connected monitors
				connect_+=("$_dsp")
				# set a usable list of settings for each monitor
				# 'monitor vars;monitor name;primary;resolution'
				dsp_vars+=("$_dsp;dsp_res_$n;$_prm;$_def")
				n=$[ $n+1 ]
			done
			IFS=$ifs
	
			# set resolutions list in a script manageable lists
			d=0
			# give a list of all resolution per monitor
			for dsp1 in ${connect_[@]}; do
				query=$(xrandr -q| sed -n  "/$dsp1/,/\(\w*[A-Z]\{2,4\}\)/p"| sed -n "/\(\w*[A-Z]\{2,4\}\)/d;p"|awk '{print $1}')
				# convert result to a YAD manageable list
				query=$(printf "$query"| tr '\n' ',')
				dsp_res_+=("dsp_res_$d=$query")
				dsp_res_list+=("$query")
				d=$[ $d+1 ]
			done
			}
	fn_xrandr_config(){
		[[ $code_tag = 0 ]]|| echo -e "$g_notif >>>> start fn_xrandr_config ####\n$e_notif"
		unset basic_sets track_list
		# create the  data to display in the yad tab
		display_field_set(){
			[[ $code_tag = 0 ]]|| echo -e "$g_notif >>>> display_field_set $e_notif"
#			X=0; x=1; l=6
			monitor_filter=1
			for x_var in ${dsp_vars[@]}; do
				m_name=$(printf "$x_var"| cut -d';' -f1)
				m_res_list=$(printf "$x_var"| cut -d';' -f2)
				m_prim=$(printf "$x_var"| cut -d';' -f3)
				m_c_res=$(printf "$x_var"| cut -d';' -f4)
#				reso_list=${dsp_res_list[$X]}
				reso_list=${dsp_res_list[@]}
				monitor=$m_name
				if [ $m_prim -gt 0 ]; then
					field_msg0="$nf $m_name (primary)$end"
				else
					field_msg0="$nf $m_name$end"
				fi
				# this function can detect all attached displays, but the actual script can't manage
				# multidisplay at this state. Then, the below conditional filter is added to only
				# manage one display, the primary.
				field_msg1="$nf Choose app resolution$end"
				field_line="$bck_mode,$reso_list;bck_mode;;$field_msg0;CB;;$monitor
$set_mode,$reso_list;set_mode;;$field_msg1;CB;;$monitor"
			done			
		}
		get_pointer_list(){
			[[ $code_tag = 0 ]]|| echo -e "$g_notif >>>> get_pointer_list$e_notif"
			xinput_list=$(xinput list | grep "pointer"|grep -v "master\|XTEST"| \
			perl -pe "s|^.* ([A-Z].*[a-z]) (\w*[A-Z]+.*id=[0-9]*)+.*$|\1 \2|;s|([ ]*)\t|;|p")
			
			mouse_list=$(printf "${xinput_list[@]}"|cut -d';' -f1|tr '\n' ','|sed -n "s/,$//p")
		}
		# define the most as possible desktop enviroment name, then check if they are in bin three.
		unset dsk_unite
		desktop_prelist="cinnamon,cinnamon2d,compiz,gnome-shell,kde,lxde,marco,mate,openbox,xfce"
		desktop_prelist=( $(echo "$desktop_prelist"| tr ',' ' ') )
		for dsk_ui in ${desktop_prelist[@]}; do
			if [ $dsk_ui == 'mate' ]; then dsk_chk='marco'; else dsk_chk=$dsk_ui; fi
			if [ $(find /usr/{bin,local/bin} -name $dsk_chk| grep -c .) -gt 0 ]; then
				dsk_unite+=("$dsk_ui")
			fi
		done
		desktop_list=$(echo "${dsk_unite[*]}"| tr ' ' ',' )

		# first establish lists for seeked values
		track_list=('auto_set' 'set_desktop_env' 'mouse_set')
		input_vars=('set_output' 'set_mode' 'bck_mode' \
		'default_desktop' 'secondary_desktop' 'mouse_dev' 'set_buttons')
		
		# get previous config if any, but take care of unexistant modules in the file
		_inputs=( "${track_list[@]}" "${input_vars[@]}" )
		for _vars in ${_inputs[@]}; do
			eval _listed='$'$_vars
			if [[ $_listed != '' && ! $_listed =~ ^\w*unset|^0 ]]; then
				case $_vars in
					'auto_set')
						[[ $code_tag = 0 ]]|| echo -e "$g_notif >>>> get xrd conf$e_notif"
						set_output=$(printf "$set_xrandr"| cut -d' ' -f3)
						set_mode=$(printf "$set_xrandr"| cut -d' ' -f5)
						bck_mode=$(printf "$bck_xrandr"| cut -d' ' -f5)
					;;
					'mouse_set')
						[[ $code_tag = 0 ]]|| echo -e "$g_notif >>>> get mouse conf$e_notif"
						set_dev_id=$(printf "$mouse_btn"| cut -d' ' -f3)
						set_buttons=$(printf "$mouse_btn"| sed -n "s|^.*$set_dev_id \([0-9].*\)$|\1|p")
					;;
					'bck_mode') dsp_res_list+=(',unset') ;;
					'default_desktop') desktop_list="$desktop_list,unset";;
					'mouse_dev'|'set_buttons') v_unset=',unset' ;;
					*) local $_vars=$_listed ;;
				esac
			else
				case $_vars in
					'auto_set'|'set_desktop_env'|'mouse_set') local $_vars=0 ;;
					*) local $_vars='unset' ;;
				esac
			fi
		done

#		if [[ $(printf "${input_list[0]}"| grep -c .) -gt 0 ]]; then export ${input_list[@]}; fi

		# add xrandr field to basic_sets list
		display_field_set
		# get mouse list form xinput
		get_pointer_list
		# window messages
		w_text="$bf Configure XRandr Wine app resolution$end\\n$vb\\Special fullscreen mode issue: Change the default desktop resolution.$end"
		w_xrandr_tip="$vb\\In some cases, older game could occur issues when set in fullscreen, the options below allow to set the resolution before the start and then back to default when stop. (also useful for Optimus display behaviour).$end"
#		w_text="$bf Configure XRandr Wine app resolution$end"
		w_xrandr_tip0="$vb\\Desktop main monitor resolution is currently set to$end $nf$current_res$end"
		w_xrandr_def_dsp="$vb\\Select the output to switch to $vn(second line)$end and resolution to switch back $vn(first line)$end$end"
		w_xrandr_tip1="$nf Note:$end Configure connected display only. Primary doesn't necessary mean current connected monitor."
	
		w_xrandr_res_to="Choose app resolution"
		w_xrandr_res_bk="Choose the resolution to swith back"
		w_xrandr_tip2="$bf Compositing$end"
		w_xrandr_tip3="$vb\\If your desktop manager slow down graphic performance, you can try to replace the default one by a lighter.$end"
		w_xrandr_tip6="$nf Note:$end In cinnamon, desactivate compositing in fullscreen mode in System Settings menu: Preferences > General"
		w_xrandr_compo1="$nf Select the default manager$end"
		w_xrandr_compo2="$nf Select the replacement manager\t$end"
		w_xrandr_tip4="$bf\\Mouse buttons setting$end"
		w_xrandr_tip5="$vb\\If you have change the mouse button placement, replacement window manager can reverse your set. This option allow you to preserve it$end"
		w_xrandr_mouse="$nf Select the mouse device$end"
		w_xrandr_buttons="$nf Select the button preset$end"
		
		basic_sets="'';;;;LBL;;
'';;;$w_xrandr_tip;LBL;;
'';;;;LBL;;
'';;;$w_xrandr_tip0;LBL;;
'';;;$w_xrandr_def_dsp;LBL;;
'';;;$w_xrandr_tip1;LBL;;
${field_line[@]}
'';;;;LBL;;
'';;;$w_xrandr_tip3;LBL;;
'';;;$w_xrandr_tip6;LBL;;
$default_desktop,$desktop_list;default_desktop;;$w_xrandr_compo1;CBE;;
$secondary_desktop,$desktop_list;secondary_desktop;;$w_xrandr_compo2;CBE;;
'';;;;LBL;;
'';;;$w_xrandr_tip4;LBL;;
'';;;$w_xrandr_tip5;LBL;;
$mouse_dev,$mouse_list$v_unset;mouse_dev;;$w_xrandr_mouse;CB;;
$set_buttons,1 2 3,3 2 1$v_unset;set_buttons;;$w_xrandr_buttons;CB;;"
		[[ $code_tag = 0 ]]|| echo -e "$g_notif\n>>>> end fn_xrandr_config ####\n$e_notif"
		
		item_sep=","
		# start form display
		win_type=1
		## focused field
		focus=''
		default_win_design
		# window style and function
		
	}
	fn_optimus_config(){
		[[ $code_tag = 0 ]]|| echo -e "$g_notif\n>>>> start fn_optimus_config ####\n$e_notif"
		unset basic_sets track_list
		# window messages
		w_text="$bf Optimus special options and sets$end\\n$vb\\If you own a Optimus Laptop, you can set here the dedicated commands and options.$end"
		w_text_tip="$vb\\If you own a Optimus Laptop, you can set here the dedicated commands and options usualy use by Linux Optimus manager.$end"
		w_opti_warn="$nf\\Note:$end For games, we strongly recommand to use Nvidia-Prime instead of Bumblebee. there's a few tools on the Web, Google them!"	
		w_opti_tip0="$vb\\Choice for Bumblebee can be primus or virtualgl as virtualizer.$end"
		w_opti_tip1="$nf\\Note: unset will use Bumblebee default virtualizer$end"
		w_opti_tip2="$vb\\Primus SYNC environment option is sometime useful in bad frame render$end"
		w_opti_tip3="$vb\\Vertical Sync to vblank is usualy not use because of a virtualizer issue$end"
		w_opti_starter="$nf Select the Optimus launcher\t\t\t$end"
		w_opti_opts="Set the Bumblebee (b) option"
		w_opti_accel="$nf Set the virtualizer$end"
		w_opti_sync="Set the primus SYNC option (optional)"
		w_opti_vblank="Set Vertical Sync (optional)"
		
		track_list=('opti_starter' 'opti_accel' 'opti_SYNC' 'opti_VBLK')
		for trk_set in ${track_list[@]}; do
			eval trk_field='$'$trk_set
			if [[ $trk_set =~ opti_starter|opti_accel ]]; then
				if [[ $trk_field == '' ]]; then
					local $trk_set='unset'
					local d_set_$trk_set=''
				else
					local d_set_$trk_set=',unset'
				fi
			fi
		done
		# var list sets
		basic_sets="'';;;;LBL;;
$opti_starter,optirun,primusrun$d_set_opti_starter;opti_starter;;$w_opti_starter;CB;;
'';;;$w_opti_tip0;LBL;;
'';;;$w_opti_tip1;LBL;;
$opti_accel,virtualgl,primus$d_set_opti_accel;opti_accel;;$w_opti_accel;CB;;
'';;;$w_opti_tip2;LBL;;
$opti_SYNC;opti_SYNC;;$w_opti_sync;CHK;;
'';;;$w_opti_tip3;LBL;;
$opti_VBLK;opti_VBLK;;$w_opti_vblank;CHK;;
'';;;;LBL;;
'';;;$w_opti_warn;LBL;;"
		[[ $code_tag = 0 ]]|| echo -e "$g_notif\n>>>> end fn_optimus_config $e_notif"
		
		item_sep=","
		# start form display
		win_type=1
		## focused field
		focus=''
		default_win_design
		# window style and function
		
	}
	last_bin(){
		[[ $code_tag = 0 ]]|| echo -e "$g_notif\n>>>> get last wine bin$e_notif"
		if [ $line = 0 ]; then
			ct_msg=1
		else
			ct_msg=0
		fi
		file_list=( _pol32 _pol64 _hq_stb0 _hq_stg0 _hq_dev0 _hq_stg1 _hq_stg2 )
		for hint in ${file_list[@]}; do
			if [ $ct_msg -gt 0 ]; then
				_last=( $hint=$(cat $HOME/.winestarter/resources/ftp$hint.\[list\] | sed -n 's/*$//g;1p') )
				export $_last
				export $hint'_list'=$(cat $HOME/.winestarter/resources/ftp$hint.\[list\]| cut -d',' -f1|\
				tr '\n' '#'| sed -n "s/#$//g;p")
			else
				_last=( $hint=\"no data available\" )
				export $_last
			fi
		done
	}
	## if BASH_PID is not null, launch a "wait please" UI until Wine packages infos are donwloaded 	
	if [[ $BASH_PID != null ]]; then
		wait_message="$vb\Updating Wine packages list and news.$end"
		fn_plz_wait &
		WAIT_UI=$(pgrep -n yad)
	fi
	key=$RANDOM
	sleep 1
	kill $YAD_PID
	messages
#	control_line
	unset active_values active_export inactive_values inactive_export cl
	## create 2 temp file for all conf section edit.
	TEMP_conf=$(mktemp --tmpdir tmp1.XXXXXXXX)
	TEMP_edit=$(mktemp --tmpdir tmp2.XXXXXXXX)
	if [[ -s $HOME/.config/user-dirs.dirs ]]; then
		. $HOME/.config/user-dirs.dirs
	fi
	if [ $from_config = 1 ]; then
		ifs=$IFS
		IFS=$(echo -en "\n\b")
		# all active values extraction with the 'export'
		active_values+=(
		$(cat $config_file | sed -n "s|^export||;s|^\(\w*[a-z].*\)=\(.*\).*$|\1=\2|p"|sed -n "s|['\|\"]||g;p")
		)
		# 'export'ed values extraction
		active_export+=( $(
		_export=$(cat $config_file | sed -n "s|^\(\w*[a-z].*\)=\(.*\).*$|\1=\2|;s|^export ||p")
			for _rewrite in '__GL_THREADED_OPTIMIZATIONS' '__GL_YIELD'; do
				case $_rewrite in
					'__GL_THREADED_OPTIMIZATIONS') _export=$(echo "$_export"| \
					sed -En "s/^(LD_PRELOAD=.*)(__GL_THREADED_OPTIMIZATIONS=[0-9])/\2/i;p")
					;;
					'__GL_YIELD') _export=$(echo "$_export"| \
					sed -En "s/^(__GL_YIELD)=([\"]?)(\w*)([\"]?)$/\1=\3/i;p")
					;;
				esac 
			done
			echo "$_export") )
		# inactives values extraction
		inactive_values+=(
		$(cat $config_file | sed -n "s|^#\(\w*[a-z].*\)=\(.*\).*$|\1=unset|p"| grep -v "export")
		)
		# inactives 'export' values extraction
		inactive_export+=(
		$(cat $config_file | sed -n "s|^#\(\w*[a-z].*\) \(.*\)=\(.*\).*$|\2=unset|p")
		)
		if [ ${#active_values} -gt 0 ]; then local "${active_values[@]}"; fi
		if [ ${#active_export} -gt 0 ]; then local "${active_export[@]}"; fi
		if [ ${#inactive_values} -gt 0 ]; then local "${inactive_values[@]}"; fi
		if [ ${#inactive_export} -gt 0 ]; then local "${inactive_export[@]}"; fi
		IFS=$ifs
		fn_wine_elf_query
#		root_key="Program Files/"
		cat $config_file > $TEMP_conf
	fi
	## don't kill Wine packages information control 'wait' UI before bash process end.
	if [[ $BASH_PID != null ]]; then
		while [ $(ps -p $BASH_PID | grep -c .) -gt 1 ]; do
			sleep 1
		done
		kill $WAIT_UI
	fi
	last_bin
#	exit 0
	section_list=('_wine' '_wbin' '_install' '_tricks' '_reged' '_nvidia_1' '_nvidia_2' '_xrandr' '_optimus' '_extended')
	for s_var in ${section_list[@]}; do
		eval f_var='$'$s_var
		if [[ $f_var == '' ]]; then
			local $s_var=0
		fi
	done
	
	if [ $(printf "${cl[*]}"| grep -c .) -gt 0 ]; then local "${cl[@]}"; fi
	get_xrandr_list
	if [ $code = 0 ]; then
		if ! [ -s $HOME/.winestarter/default-wine ]; then touch $HOME/.winestarter/default-wine; fi
		if [[ $wine_bin != '' ]]; then
#		if [[ $wine_bin == '' ]]; then
			if [[ -x $wine_bin ]]; then
				sys_version=$($wine_bin --version)
			else
				sys_version='not installed'
			fi
			if [ $b_set = 1 ]; then
				fn_basics_config
			else
				fn_create_prefix			
			fi
		else
			fn_binary_env
		fi
	else
		fn_nvidia_config
	fi
	
}
########### MAIN ###########
export wine_bin=$(find /usr/{bin,local/bin} -name wine)
export wineserver_bin=$(find /usr/{bin,local/bin} -name wineserver)
export w_tricks_bin=$(find /usr/{bin,local/bin} -name winetricks)
export yad_bin=$(find /usr/{bin,local/bin} -name yad)
export zen_bin=$(find /usr/{bin,local/bin} -name zenity)
export conv_bin=$(find /usr/{bin,local/bin} -name convert)
export icot_bin=$(find /usr/{bin,local/bin} -name icotool)
export wres_bin=$(find /usr/{bin,local/bin} -name wrestool)
export lpci_bin=$(find /{bin,sbin} /usr/{bin,sbin} -name lspci)
export rpm_bin=$(find /usr/{bin,local/bin} -name rpm2cpio)
export cab_bin=$(find /usr/{bin,local/bin} -name cabextract)
## control yad presence and exit if none.
if ! [[ $yad_bin ]]; then
	echo -e "## !!! No Yad binary found.\n## !!! Install it first !"
	exit 0
fi
# PlayOnLinux packages download window
# select_win_bin(){ colors ; icons_set ; select_wine_bin; }
edit_reg_bin(){ colors ; icons_set ; edit_regfile; }
edit_regfile(){
#	reg_move=$(mktemp --tmpdir reg2.XXXXXXXX)
	reg_edit=$(mktemp --tmpdir reg3.XXXXXXXX)
#	reg_temp=$(mktemp --tmpdir reg4.XXXXXXXX)
	reg_display=$(cat $reg_file| perl -pe "s|\\\|\\\\\\\|g;p"| tr '*' '\n')
	
	w_text="$bf\\Register manual edit$end\\n \
$nf\\All custom maunal changes in the text area will be merge with others presets.$end"
	w_com0="$vb Custom register (manual edit).$end"
	w_com1="$rb\\Warning:$end$vb Remove all custom (set by yourself) or empty lines$end"

	reg_popup=$(
	$yad_bin --width=400 --title "$w_title" --image="$img_wine_desk_ui" --borders=15 \
	--window-icon="$img_wine_desk_ui" --form --text="$w_text" --separator=" " --item-separator="#" \
	--field="$w_com1":LBL '' --field="$w_com0":TXT "$reg_display")
	
	if [ $? = 0 ]; then
		printf "$reg_popup"| tr '\n' '*' > $reg_edit
		export reg_edit=$reg_edit
	else
		exit 0
	fi
	
}
edit_wine_options(){
	colors ; icons_set
	# form: "$_msc_short;$_msc_arg;$_msc_var;0"
	## make a readable list
	options_list=( $(cat "$option_log") )
	for opt in ${options_list[@]}; do
		## cut the sets in file to make variables
		_active=$(printf "$opt"| cut -d";" -f4)
		_option=$(printf "$opt"| cut -d";" -f2)
		## define if variables are already active in resources conf file
		if [[ -s $option_conf ]]; then
			if [ $(cat "$option_conf"| egrep -c "$_option") -gt 0 ]; then
				_definition="$(cat "$option_conf"| egrep "$_option"| cut -d";" -f2)"
				_active=1
			else
				_definition="enter a short description"
			fi
		fi
		## define the default tip message
		# _help_tip=""
		## make 'active' conf usable by yad
		if [ $_active -gt 0 ]; then
			col+=("TRUE" "$_option" "$_definition")
		else
			col+=("FALSE" "$_option" "$_definition")
		fi
	done
	## set tip and help texts
	conf_txt="$bf\\Add options to default list$end\\n$vb\\Choose manually added options to default options menu list. They will be kept for all future bottles.$end\\n$rb\\WARNING:$end Added options can be only remove from the original bottle or by manual edit into default options list file."
	## create the yad window with the properly setted variables 
	change_opts=$($yad_bin --width=500 --height=400 --title= --image="$img_wine_opts" --borders=15 \
	--window-icon="$img_desktop" --list --checklist --text="$conf_txt" --editable --separator=";" \
	--print-all --column="Active" --column="Option" --column="Descriptions" \
	"${col[@]}")
	## second part: load pined options into opntions.list
	## form: TRUE;option;description; > option;description
	## prepare script to read yad output lines
	ifs=$IFS
	IFS=$(echo -en "\n\b")
	## analyse yad output and add or remove in options conf file
	for _chg_opt in ${change_opts[@]}; do
		## cut the sets in file to make variables
		_chg_active=$(printf "$_chg_opt"| cut -d";" -f1)
		_chg_option=$(printf "$_chg_opt"| cut -d";" -f2)
		_chg_definition=$(printf "$_chg_opt"| cut -d";" -f3)
		## probe if variables active or inactive, then add or remove them if any
		if [[ $_chg_active == TRUE ]]; then
			## add option to default winestarter wine option conf
			_act_num=1
			if [ $(cat $option_conf| grep -c "$_chg_option") -eq 0 ]; then
				sed -E -ni "s/(^misc.*$)/$_chg_option;$_chg_definition\n\1/i;p" $option_conf
			fi
		else
			_act_num=0
			## if unset, remove custom wine option from wine options conf 
			if [ $(cat $option_conf| grep -c "$_chg_option") -gt 0 ]; then
				modified_conf=$(cat $option_conf| grep -v "$_chg_option")
				printf "$modified_conf" > $option_conf
			fi
		fi
		sed -E -ni "s/(^.*;$_chg_option.*);([0-9])/\1;$_act_num/i;p" $option_log
	done
	## restore IFS and exit to previous window
	IFS=$ifs
}

control_last(){
	date_stamp(){
		file_temp=$(mktemp --tmpdir ftp_date.XXXX)
		select_dev0
		elf=$(printf "${tags}"| cut -d',' -f1)
		http_elf=$(printf "${tags}"| cut -d',' -f2)
		http_class=$(printf "${tags}"| cut -d',' -f3)
		wget -O $file_temp $dl_address/
#		os_v=$(tac $file_temp | egrep -o "indexcolname.*href=\"[0-9]{2}\/\""| \
#		sed -En "s/^.*([0-9]{2}).*$/\1/;1p")
		os_version=$(tac $file_temp | sed -En "s|^.*href=\"([0-9]{2})\/\".*$|\1|p")
		os_v=$(echo "$os_version"| sed -n '1p')
		wget -O $file_temp.[$os_v] $dl_address/$os_v/$http_elf
		last_bin_date=$(tac $file_temp.[$os_v] | egrep "wine-$hq_stage$elf-[0-9]+"| \
		sed -En "s/^.*indexcollastmod\">([0-9]{4}-[0-9]{2}-[0-9]{2}) [0-9]+:[0-9]+.*$/\1/;1p")
		last_bin_date=$(printf "$last_bin_date"| sed -n "s/-//g;p")
		
		if [[ -s $HOME/.winestarter/last-update ]]; then
			previous_bin_date=$(cat $HOME/.winestarter/last-update|sed -n "s/-//g;p")
			if [ $last_bin_date -gt $previous_bin_date ]; then
				update=1
				echo -n "$last_bin_date" > $HOME/.winestarter/last-update
			else
				update=0
			fi
		else
			echo -n "$last_bin_date" > $HOME/.winestarter/last-update
			update=1
		fi
	}
	download_list(){
	if [ $bin_class -gt 0 ]; then
	wget -O $file_temp $dl_address
	## WineHQ give multiple repos for fedora project. To get all availables, we take in all fedora
	## version and put them in a single var.
		os_version=$(tac $file_temp | sed -En "s|^.*href=\"([0-9]{2})\/\".*$|\1|p")
#		os_version=$(tac $file_temp | egrep -o "indexcolname.*href=\"[0-9]{2}\/\""| \
#		sed -En "s/^.*([0-9]{2}).*$/\1/p")
		for os_v in ${os_version[@]}; do
			wget -O $file_temp.[$os_v] $dl_address/$os_v/$http_elf/
			dl_bin_list[$os_v]=$(tac $file_temp.[$os_v]| egrep "wine-$hq_stage$elf-[0-9]+"|\
			sed -En "s/^.*$elf-([0-9]\.[0-9]{1,2}(\.[0-9]{1,2})?)-([0-9](.rc[0-9])?).$http_elf.*$/\1-\3-$hq_stage,$os_v/p")
			echo "${dl_bin_list[$os_v]}"| grep -c .
		## merge only if Wine version is different.
			if [ $os_v_p ]; then
				if [ $os_v -ne $os_v_p ]; then
					new_output=$(echo "${dl_bin_list[$os_v]}"|cut -d',' -f1)
					prev_output=$(echo "${dl_bin_list[$os_v_p]}"|cut -d',' -f1)
					_diff=$(echo "$new_output"| grep -vc "$prev_output")
					[[ $_diff ]]|| _diff=0
					if [ $_diff -gt 0 ]; then
						_added='\n'$(echo "${dl_bin_list[$os_v]}"| grep -v "$prev_output")
						dl_bin_list[$os_v]=$(echo -e "${dl_bin_list[$os_v_p]}$_added")
						dl_bin_list=${dl_bin_list[$os_v]}
					else
						if [[ $_diff -eq 0 && $(echo "${dl_bin_list[$os_v]}"| grep -c .) -eq 1 ]]; then
							if [[ $new_output != $prev_output ]]; then dl_bin_list=${dl_bin_list[$os_v]}; fi
						fi
					fi
					os_v_p=$os_v
				fi
			else
				os_v_p=$os_v
			fi
		done
	else
		wget -O $file_temp $dl_address
		## limit PoL Wine version list from 1.4 to 1.8.6
		dl_bin_list=( "$(tac "$file_temp"| cut -d';' -f2| sed -n '/1\.8\.6.*$/,/^1\.4$/p')" )
	fi
	eval local_bin_list='$'{local_bin_$http_class[@]}
	if [ ${#local_bin_list[@]} -gt 0 ]; then
		for existing in ${local_bin_list[@]}; do
			if [ $bin_class -gt 0 ]; then
				if [ $(printf "$dl_bin_list"| egrep -wc "$existing,.*$") -gt 0 ]; then
					dl_bin_list=$(echo "$dl_bin_list"| sed -En "s/^($existing),(.*$)/\1*,\2/g;p")
				fi
			else
				if [ $(printf "$dl_bin_list"| egrep -wc "$existing") -gt 0 ]; then
					dl_bin_list=$(echo "$dl_bin_list"| sed -En "s/^($existing)/\1*/g;p")
				fi
			fi
		done
	fi
	echo "$dl_bin_list" > $HOME/.winestarter/resources/ftp$tmp_list.[list]
	unset dl_bin_list
	}
	## stable wine versions
	select_stb0(){ hq_stage='stable'; tmp_list='_hq_stb0'; dir_ver='wine-builds'; select_hq; }
	## version newer than 2.4
	select_stg0(){ hq_stage='staging'; tmp_list='_hq_stg0'; dir_ver='wine-builds'; select_hq; }
	select_dev0(){ hq_stage='development'; tmp_list='_hq_dev0'; dir_ver='wine-builds'; select_hq; }
	## version older than 2.4 from 1.9.16
	select_stg1(){ hq_stage='staging'; tmp_list='_hq_stg1'; dir_ver='wine-builds.old'; select_hq; }
	select_stg2(){ hq_stage='staging'; tmp_list='_hq_stg2'; dir_ver=''; select_hq; }
#	select_dev1(){ hq_stage='development'; tmp_list='_hq_dev'; dir_ver='wine-builds.old'; select_hq; }
	select_hq(){
		bin_class=1
		if [[ $dir_ver ]]; then
			web_src='dl.winehq.org/'$dir_ver
		else
			## TODO < to remove in case merge between WineHQ staging repo and third party.
			web_src='repos.wine-staging.com/alesliehughes'
		fi
		dl_address="https://$web_src/fedora"
		site='WineHQ'
#		tags=(',i686,x86' '64,x86_64,amd64')
		tags=('64,x86_64,amd64')
	}
	## version older than 1.9.16
	select_pol_32(){ list_elf='32'; tags='32,x86,x86'; select_pol; }
	select_pol_64(){ list_elf='64'; tags='64,amd64,amd64'; select_pol; }
	select_pol(){
		bin_class=0
		list_class=$(printf "$tags"| cut -d',' -f2)
		dl_address="http://wine.playonlinux.com/binaries/linux-$list_class.lst"
		site='PlayOnLinux'
		tmp_list="_pol$list_elf"
	}
	download_section(){	
		# ls already insbtalled packages if any
		tag_cmd=('select_pol_32' 'select_pol_64' 'select_stb0' 'select_stg0' 'select_dev0' 'select_stg1' 'select_stg2')
#		tag_cmd=('select_stb0' 'select_stg0' 'select_dev0' 'select_stg1' 'select_stg2')
#		tag_cmd=('select_dev0' 'select_stg1' 'select_stg2')
		for tag_list in ${tag_cmd[@]}; do
			${tag_list}
			file_temp=$(mktemp --tmpdir ftp$tmp_list.XXXX)
			for used_tag in ${tags[@]}; do
				elf=$(printf "$used_tag"| cut -d',' -f1)
				http_elf=$(printf "$used_tag"| cut -d',' -f2)
				http_class=$(printf "$used_tag"| cut -d',' -f3)
				download_list
			done
		done
	}
	date_stamp
	if [ $line = 0 ]; then
		ct_msg=1
	else
		ct_msg=0
	fi
	export ct_msg=$ct_msg
	export BASH_PID='null'
	if [ $ct_msg -gt 0 ]; then
		if [ $update -gt 0 ]; then
			wine_path=$HOME/.winebin
			if [[ -d $wine_path && "$wine_path" != "$HOME" ]]; then
				local_bin_x86=( $(ls -1 $wine_path/x86) )
				local_bin_amd64=( $(ls -1 $wine_path/amd64) )
			fi
			download_section &
			BASH_PID=$(pgrep -n bash)
			export BASH_PID=$BASH_PID
		
		fi
	fi
}
### main ui buttons functions
## manage configs and bottles
#delete_conf(){}
## manage ui font colors
change_fonts_colors(){
	unset font_color color_fonts prev_colors prev_fonts
	sleep 1
	kill $YAD_PID
	w_text="$bf\\Basic font colors and style$end$vb\\n\
Change UI fonts colors and kind at will, but keep in mind the sens of each of them: main, warning, unavialable.$end"
	w_tip="$rb\\WARNING$end$vn: Don't select fonts with more than 2 words if it's not a \"regular\" or \"italic\", it won't be displayed correctly.\nYou can also extend window width up to 100px if the horizontal scrollbar still appears in some tabs.$end"
	font_color=$($yad_bin --width=480 --height=300 --title "$w_title" --image="$img_wine_desktop" \
		--window-icon=$img_wine_desk_ui --text "$w_text" --form --separator="|" --item-separator="," \
		--borders=15 --field="":LBL '' \
		--field="$vb Main messages color\t\t$end":CLR "$main" \
		--field="$vb Warning messages color$end":CLR "$warn" \
		--field="$vb Unavialable messages color$end":CLR "$freeze" \
		--field="$vb Normal font type$end":FN "$font0 $size0" \
		--field="$vb Titles font type$end":FN "$font1 $size1" \
		--field="$vb Add more width to window display$end":SCL "$scale,0..100" \
		--field="$w_tip":LBL '')
	if [ $? = 1 ]; then bash $bash_opt $base_script; exit 0; fi
	if [ $? = 0 ]; then
		prev_colors=$(printf "$font_color"| sed -n "s/^|//;s/\(^.*\)||/\1/p" ) #
		
		ifs=$IFS
		IFS='|'
		for i in ${prev_colors[@]} ; do
			color_fonts+=("$i")
			echo "$i"
		done
		echo "${color_fonts[@]}"
		IFS=$ifs
		C=0 ; D=0
		## main color/font vars
		fields=( 'main' 'warning' 'freeze' 'norm' 'big' 'scale' )
		## stick collected new vars to script vars 
		for colr in ${fields[@]}; do
			previous=${color_fonts[$C]}
			if [[ $colr == norm || $colr == big ]]; then
				## divide font block name into font name and size
				echo "$D"
				size=$(printf "$previous"| grep -o "[0-9]*")
				font=$(printf "$previous"| sed -n "s/\(^.*\) [0-9]*/\1/p")
				new_fields+=("font$D;$font")
				new_fields+=("size$D;$size")
				D=$[ $D+1 ]
			else
				new_fields+=("$colr;$previous")
			fi
			C=$[ $C+1 ]
		done
		for f in "${new_fields[@]}"; do
			cl_var=$(printf "$f"| cut -d';' -f1)
			cl_val=$(printf "$f"| cut -d';' -f2)
			perl -ni -pe "s|(^$cl_var=)'.*'$|\1'$cl_val'|i" $HOME/.winestarter/color.conf
		done
		bash $bash_opt $base_script
	fi
	exit 0
}
## get configured bottles list mandatory for other modules use.
colors ; icons_set
list_bottles(){
	if [[ -d $HOME/.winestarter/configs ]]; then
		if [ $(ls -1 $HOME/.winestarter/configs/| egrep -c "*[.conf]$") -gt 0 ]; then
			config_list=$(ls -1 $HOME/.winestarter/configs/| egrep "*[.conf]$")
			for config in ${config_list[@]}; do
				b_conf=$config
				b_name=$(cat $HOME/.winestarter/configs/$config| grep -w "bottle_prefix="|sed -n "s/^.*=\"\.//;s/\"//p" )
				bottle_list+=("$b_name")
				bottle+=("$b_name;$b_conf")
			done
			bottle_list=$(printf "${bottle_list[*]}"|sed -n "s/ /#/g;p")
		else
			bottle_list="none"
		fi
	fi
}
## edit or create a new desktop file entry.
edit_desktop(){
	## clear all lists
	unset desk_var_list def_list icon_id icon_def
	sleep 1
	## kill previous yad window
	kill $YAD_PID
	## load the config file
	. $config_file
	## define th default winestarter path
	_path_set=$HOME/.winestarter
	_img_set=$_path_set/png
	emblem_png=$_path_set/emblems/wine_emblem.png
	## define the basic vars to create a desktop file
	desk_var_list=('user_prefix' 'bottle_prefix' 'game_dir' 'game_exe' 'wine_elf')
	for d_var in ${desk_var_list[@]}; do
		eval _conf_set='$'$d_var
		appli_dir_set+=("$d_var=$_conf_set")
	done
	## apply them as vars to be sued by the script
	local "${appli_dir_set[@]}"
	## extract and create thumbnails of the app icons in pngs
	ifs=$IFS
	IFS=$(echo -en "\n\b")
	# set the exe path and bin
	if [[ $game_exe =~ ^.*\.(exe|EXE)$ ]]; then
		if [[ -d $user_prefix/$bottle_prefix/drive_c/$game_dir ]]; then
			exe_path="$user_prefix/$bottle_prefix/drive_c/$game_dir/$game_exe"
		else
			exe_path="$user_prefix/$bottle_prefix/drive_c/Program Files$elf_ext/$game_dir/$game_exe"
		fi
		# set the icon type to extract
		ico_type=14
		# extract the icon
		$wres_bin -x -t $ico_type -o $_path_set/icons $exe_path
		exe_name=$(printf "$exe_path"| sed -n "s|^.*/||g;p")
		default_name=$(printf "$exe_name"| sed -n "s/.exe$//p")
	else
		exe_path='unknown'
		exe_name='unknown'
		default_name='unknown'
	fi
	
	config_name=$(printf "$config_file"|sed -n "s|^.*/||p")
#	IFS=$ifs
	# predefine category set default value. Will be overwrited if desktop file entry exist
	cat_set='unset'
	## control if there is an existing desktop file
	# define the main Desktop directory
	. $HOME/.config/user-dirs.dirs
	desktop_vars=(
		"1,Name,5"
		"1,Comment,6"
		"0,Exec,winestarter $config_name"
		"2,Icon,2"
		"0,StartupWMClass,$exe_name"
		"1,dsk_menu,10"
		"1,Categories,7"
		"1,emblem,12")
	# extract the png from the icon in multi definition format
	def_list=('256' '128' '64' '48')
	if [[ $exe_name != unknown ]]; then
		for _def in ${def_list[@]}; do
			# look for index for the asked definition
			idx=$($icot_bin -l $_path_set/icons/$exe_name\_$ico_type\_*.ico| \
			grep "\(width=$_def\).*\(bit-depth=32\)"| sed -n "s/^.*--index=\([0-9]\).*$/\1/g;p")
			if [[ $idx > 0 ]]; then
				$icot_bin -x -i $idx -o $_path_set/png $_path_set/icons/$exe_name\_$ico_type\_*.ico
				png_file=$(ls -1 $_path_set/png/$exe_name\_$ico_type*\_$_def\x$_def*.png)
				if [[ -s $png_file ]]; then
				thb_file=$_path_set/png/thumb/$(printf "$png_file"| sed -n "s/^.*\///g;p")
				# create thumbnail for yad UI
				$conv_bin $png_file -scale 48x48 $thb_file
				else
					png_file=$_path_set/png/defaults/warning.png
					thb_file=$_path_set/png/defaults/warning.png
				fi
				# make def field readable
				png_def="$_def"x"$_def"
				icon_id+=("$thb_file")
				icon_id+=("$png_file")
				icon_id+=("$png_def")
				icon_def+=("$png_file,$png_def")
			fi
		done
	
		# extract the desktop file entry variables, if any, and make them usable by the script
		if [[ -e $XDG_DESKTOP_DIR/$exe_name.desktop ]]; then
			[[ $code_tag = 0 ]]|| echo -e ">>>>>>>>>>>>>>>>>\n"
#			ifs=$IFS
#			IFS=$(echo -en "\n\b")
			desktop_data=( $(cat $XDG_DESKTOP_DIR/$exe_name.desktop| egrep -v "^\[.*\]$") )
			for _vars in ${desktop_data[*]}; do
				_var=$(printf "$_vars"| cut -d'=' -f1)
				_val=$(printf "$_vars"| cut -d'=' -f2)
				case $_var in
	#				'Type');;
					'Exec') if [ $_val ]; then default_cmd=$_val; fi;;
					'StartupWMClass') if [ $_val ]; then exe_name=$_val; fi;;
					'Name') if [ $_val ]; then default_name=$_val; fi;;
					'Comment') default_desc=$_val;;
					'Categories') if [ $_val ]; then cat_set=$_val; else cat_set='unset'; fi;;
					'Icon') png_file=$_val;;
				esac
			done
#			IFS=$ifs
			## add the desktop icon to the icon list if extracted from the desktop file entry
			# make a thumbnail for yad UI
			# test first if theere is already a corresponding image in path.
			if ! [ -s $_path_set/png/thumb/$exe_name.png ]; then
				thb_file=$_path_set/png/thumb/$(printf "$png_file"| sed -n "s/^.*\///g;p")
				$conv_bin $png_file -scale 48x48 $thb_file
			else
				png_file=$_path_set/png/$exe_name.png
				thb_file=$_path_set/png/thumb/$exe_name.png
			fi
			if ! [[ $png_file ]]; then
				png_file=$_path_set/png/defaults/warning.png
				thb_file=$_path_set/png/defaults/warning.png
			fi
			# get image dimensions
			png_def=$(file $png_file | sed -En "s| ||g;s|^.*,([0-9]*.*)x([0-9]*.*),[0-9].*$|\1x\2|p")
			# add it to the list
			icon_id+=("$thb_file")
			icon_id+=("$png_file")
			icon_id+=("existing desktop file entry,$png_def")
			icon_def+=("$png_file,$png_def")
		fi
	else
		icon_id=("$_path_set/png/defaults/unknown.png" "$_path_set/png/defaults/unknown.png" "no default png found,48x48")
	fi
	IFS=$ifs
	## window messages and tips
	w_text="$bf Create a dedicated desktop file$end \\n \
$vb You can create or modify every main fields of a desktop file$end"
	w_tip0="$vb\Select an icon for you desktop file from the right list$end"
	w_tip1="$vb\Choose or edit a display name, a description and a menu category for the desktop file$end"
	w_tip2="$vb\By default, desktop entry is add to the deskop only $end"
	w_tip3="$vb\Winestarter automatical add a Wine emblem to easely detach its managed softwares. You can remove it by unsetting the check box here.$end"
	w_custom_icon="$vb\\Select a custum icon instead of listed$end"
	## create paned window and send result to associated temp files
	key=$RANDOM
	temp1=$(mktemp --tmpdir tab1.XXXXXXXX)
	temp2=$(mktemp --tmpdir tab2.XXXXXXXX)
	# editable categories list for Category entry combo box
	categories='Game;,Office;,Applications;,Multimedia;,Video;,Graphics;'
	# select_pan part
	$yad_bin --width=440 --height=300 --plug=$key --tabnum=1 --form \
			--item-separator="," --borders=5 --field="":LBL '' \
			--field="$w_tip0":LBL '' \
			--field="":LBL '' \
			--field="$w_tip1":LBL '' \
			--field="$vb Name$end": "$default_name" \
			--field="$vb Comment$end": "$default_desc" \
			--field="$vb Category$end":CBE "$cat_set,$categories" \
			--field="":LBL '' \
			--field="$w_tip2":LBL '' \
			--field="Add the dessktop entry to the dedicated type menu":CHK TRUE \
			--field="$w_tip3":LBL '' \
			--field="Add a Wine sticky emblem in top right corner":CHK TRUE \
			--field="$w_custom_icon":LBL '' \
			--field="$vb Custom icon$end":FL "$HOME/" \
			--separator=',' &> $temp1 &
	# icon_pan part
	$yad_bin --width=60 --height=300 --plug=$key --tabnum=2 --borders=5 --list \
			--tooltip-column=3 --hide-column=3 --no-rules-hint --separator=',' \
			--column='icon list':IMG --column='path':HD --column='tip':TIP \
			"${icon_id[@]}" &> $temp2 &
	# main paned window
	w_width=$((520+$scale))
	w_splitter=$((380+$scale))
	$yad_bin --width=$w_width --height=300 --title "$w_title" --window-icon=$img_wine_desk_ui \
	--borders=15 --text "$w_text" --paned --key=$key --orient=hor --splitter=$w_splitter
	if [ $? = 1 ]; then bash $bash_opt $base_script; exit 0; fi
	## extract setted variable from temp files
	# create a new temp file if creating a new desktop file
	temp3=$(mktemp --tmpdir desktop.XXXXXXXX)
	# order temp file by variable raws
	tmp_files=("0," "1,$temp1" "2,$temp2")
	rk=0
	for tmp in ${tmp_files[@]}; do
		tp_rk=$(printf "$tmp"| cut -d',' -f1)
		tp_fl=$(printf "$tmp"| cut -d',' -f2)
		if [ $rk -eq $tp_rk ]; then
			#make sure data come from temp file or not
			if [[ $tp_fl != '' ]]&&[ -e $tp_fl ]; then
				tmp_data=$(cat $tp_fl)
			fi
			for t_vars in "${desktop_vars[@]}"; do
				tmp_rank=$(printf "$t_vars"| cut -d',' -f1)
				dsk_var=$(printf "$t_vars"| cut -d',' -f2)
				dsk_rank=$(printf "$t_vars"| cut -d',' -f3)
				#control again if data come from temp file or not, then apply correct filter
				if [ $tmp_rank = $tp_rk ]&&[[ $dsk_rank != '' ]]; then
					if [ $tp_fl	!= '' ]&&[ -e $tp_fl ]; then
						dsk_field=$(printf "$tmp_data"|cut -d',' -f$dsk_rank)
					else
						dsk_field=$dsk_rank
					fi
					desktop_field+=("$dsk_var=$dsk_field")
				fi
			done
			rk=$[ $rk+1 ]
		fi
	done
	convert_icon=0
	ifs=$IFS
	IFS=$(echo -en "\n\b")
	# take emblem png definition from file
	emblem_def=$(file $emblem_png| perl -pe "s| ||g;s|^.*,([0-9]*.*)x([0-9]*.*),[0-9].*$|\1x\2|p")
	## parse now data to desktop entry
	for keys in "${desktop_field[@]}"; do
		fld_var=$(printf "$keys"| cut -d'=' -f1)
		fld_entry=$(printf "$keys"| cut -d'=' -f2)
		# if emblem overlay is selected, check vlaue first before telling to script to create 
		# the overlay at the next loop.
		if [ "$fld_entry" == TRUE ]; then
			if [ "$fld_var" == emblem ]; then convert_icon=1; else convert_icon=0; fi
			if [ "$fld_var" == dsk_menu ]; then menu_entry=1; else menu_entry=0; fi
		fi
		# next loop create the overlay if set.
		if [[ "$fld_var" == Icon && $convert_icon = 1 ]]; then
			for l_png in ${icon_def[@]}; do
				png=$(printf "$l_png"| cut -d',' -f1)
				def=$(printf "$l_png"| cut -d',' -f2)
				if [ $png == $fld_entry ]; then
					if [ $(printf "$fld_entry"| grep -c "$emblem_def") = 0 ]; then
						scale="-scale $def"
					fi
				fi
			done
			$conv_bin $fld_entry $emblem_png $scale -composite $_img_set/$exe_name.png
			fld_entry=$_img_set/$exe_name.png
			keys="$fld_var=$fld_entry"
		fi
		# control if this is an edit from existing file and then apply correct filter
		if [[ -a $XDG_DESKTOP_DIR/$exe_name.desktop ]]; then
			perl -ni -pe "s|^($fld_var=)(.*)$|\1$fld_entry|i" \
			$XDG_DESKTOP_DIR/$exe_name.desktop
			if [ $menu_entry = 1 ]&&[ $HOME/.local/share/applications/$exe_name.desktop ]; then
				perl -ni -pe "s|^($fld_var=)(.*)$|\1$fld_entry|i" \
				$HOME/.local/share/applications/$exe_name.desktop
			fi
		else
			if ! [[ $fld_var == emblem || $fld_var == dsk_menu ]]; then printf "$keys\n" >> $temp3; fi
		fi
	done
	# for complete new desktop file entry creation add first line headers in first place. 
	if [ ! -f $XDG_DESKTOP_DIR/$exe_name.desktop ]; then
		printf "[Desktop Entry]\nEncoding=UTF-8\nType=Application\n" > $XDG_DESKTOP_DIR/$exe_name.desktop
		cat $temp3 >> $XDG_DESKTOP_DIR/$exe_name.desktop
		chmod 755 $XDG_DESKTOP_DIR/$exe_name.desktop
		if [ $menu_entry = 1 ]; then
			touch $HOME/.local/share/applications/$exe_name.desktop
			cat $XDG_DESKTOP_DIR/$exe_name.desktop > $HOME/.local/share/applications/$exe_name.desktop
			chmod 755 $HOME/.local/share/applications/$exe_name.desktop
		fi
	fi
	IFS=$ifs
	# all done, bye bye.
	bash $bash_opt $base_script; exit 0
}
edit_bottle(){
	unset more_value
	sleep 1
	kill $YAD_PID
	list_bottles
	## options by selector window type.
	case $cmd_type in
		## 0 > conf file edition.
		0) win_icon=$img_wine_ui
			unset nv_field nv_list
			if [ $($lpci_bin| grep -c "NVIDIA") -gt 0 ]; then
				nv_field+=("--field=:LBL")
				nv_list+=('')
				nv_field+=("--field=$vb Select a Wine bottle$end:CB")
				nv_list+=("$bottle_list")
				nv_field+=("--field=$vb Select edit option$end:CB")
				nv_list+=('Edit the whole bottle#Edit config file directly#Edit Nvidia options only')
				w_text="$bf Wine bottle edition$end$vb\\n
You can choose between edit a entire bottle or the Nvidia OpenGL environment options only$end"
			else
				w_text="$bf Wine bottle edition$end$vb\\n
Select the Wne bottle to edit$end"
				nv_field+=("--field=:LBL")
				nv_list+=('')
				nv_field+=("--field=$vb Select a Wine bottle$end:CB")
				nv_list+=("$bottle_list")
				nv_field+=("--field=$vb Select edit option$end:CB")
				nv_list+=('Edit the whole bottle#Edit config file directly')
			fi
			edit_win=$($yad_bin --width=420 --title "$w_title" --image=$win_icon --borders=15 \
			--window-icon=$img_desktop --center --separator=';' --form --item-separator="#" \
			--align=left --text "$w_text" "${nv_field[@]}" "${nv_list[@]}")
		;;
		## 1 > desktop file management.
		1) w_text="$bf Wine bottle desktop file edition$end$vb\\n
Select the bottle you would like for a desktop file$end"
			win_icon=$img_wine_desk_ui
			edit_win=$($yad_bin --width=520 --title "$w_title" --image=$win_icon --borders=15 \
				--window-icon=$img_desktop --center --separator=';' --form --item-separator="#" \
				--align=left --text "$w_text" --field="":LBL '' \
				--field="$vb Select a Wine bottle\t$end":CB "$bottle_list")
		;;
		## 2 > restart features.
		2) w_text="$bf Restart and quick setup function system$end$vb\\n
You can here restart/setup some functions like Winecfg, Winetricks,etc at next Winestarter launch.
This feature could be really useful in case of a Wine prefix update, or just to quickly control/manage/setup Wine prefix and other Winestarter options.$end"
			win_icon=$img_wine_restart
			edit_win=$($yad_bin --width=420 --title "$w_title" --image=$img_wine_reload --borders=15 \
				--window-icon=$img_desktop --center --separator=';' --form --item-separator="#" \
				--align=left --text "$w_text" --field="":LBL '' \
				--field="$vb Select a Wine bottle$end":CB "$bottle_list" \
				--field=" Relaunch Winecfg UI":CHK 'FALSE' \
				--field=" Restart Winetricks install process":CHK 'FALSE' \
				--field=" Restart apps install process (if set)":CHK 'FALSE' \
				--field=" (Re)Activate Wine external binary support (if set)":CHK 'FALSE' \
				--field=" (Re)Activate optional end user GUI switch (if set)":CHK 'FALSE' \
				--field=" (Re)Activate optional mouse settings (if set)":CHK 'FALSE' \
				--field=" (Re)Activate optional xrandr settings (if set)":CHK 'FALSE' \
				)
		;;
		## 3 > manage bottle's conf file.
		3) w_text="$bf Wine bottles management$end\\n
$vb\\Rename, remove, clone.
In some case, it's easiest to just rename or clone an existing prefix than re-create a new one.$end
$nf\\Example:$end$vn creating a D3DX11 predifine prefix for all future game installation. It allow you to not have to download or configure many features again.$end"
			win_icon=$img_wine_restart
			edit_win=$($yad_bin --width=520 --title "$w_title" --image=$img_bottle_mng --borders=15 \
				--window-icon=$img_desktop --center --separator=';' --form --item-separator="#" \
				--align=left --text "$w_text" --field="":LBL '' \
				--field="$vb Select a Wine bottle\t$end":CB "$bottle_list" \
				--field="$vb Select action$end":CB 'Clone#Rename#Remove')
		;;
	esac
	if [ $? = 1 ]; then bash $bash_opt $base_script; exit 0; fi
	_edit_bottle=$(printf "${edit_win[@]}"| cut -d';' -f2)
	config_file=$HOME/.winestarter/configs/$_edit_bottle.conf
	## each button give specification by commands
	case $cmd_type in
		0) if [ $(printf "${edit_win[@]}"| grep -c "Nvidia") -gt 0 ];then
				code=1; else code=0
			fi
			## prefx edit section comes with options, if this option is config file direct edit,
			## launch zenity/yad text edit and exit.
			if [ $(printf "${edit_win[@]}"| grep -c "directly") -gt 0 ];then
				e_text="$bf\\Fast Config Edit$end\n
Editor is for quick config edits. Don't remove '##' comments they're essential for winestarter_conf."
				edit_config=$($yad_bin --width=800 --height=600 --title="$w_title" --borders=15 \
				--window-icon=$img_wine_desk_ui --text-info  --text="$vb$e_text$end" \
				--editable --filename=$config_file)
				if [ $? = 0 ]; then
					echo "$edit_config" > $config_file
				else
					bash $bash_opt $base_script; exit 0
				fi
			else
				bash_cmd="colors; icons_set; b_set=0; code=$code; main_code"
			fi
		;;
		1) bash_cmd="colors; icons_set; edit_desktop" ;;
		2) 
			## load config file first
			. $config_file
			_case_list=( '_wine,Wine Basics' '_tricks,Winetricks' '_install,Install package' '_wbin,Wine binary pack' '_xrandr,Display options' )
			for section_def in "${_case_list[@]}"; do
				section=$(printf "$section_def"| cut -d',' -f1)
				section_title=$(printf "$section_def"| cut -d',' -f2)
				eval _section='$'$section
				## work-around to get 0 value if not in conf.
				if [[ $_section == '' ]]; then _section=0; fi
				if [ $_section -gt 0 ]; then
					case $section in
						'_wine') _vars_list=( 'w_config, Winecfg,3,\t\t' );;
						'_tricks') _vars_list=( 'w_install_tricks,Winetricks,4,\t\t' );;
						'_install') _vars_list=( 'w_install_exe,Install package,5,\t\t' );;
						'_wbin') _vars_list=( 'use_winepath,Wine binary pack,6,\t' );;
						'_xrandr') _vars_list=( 'set_desktop_env,End user desktop,7,\t' 'mouse_set,Mouse devise,8,\t\t' 'auto_set,Display variable,9,\t\t' );;
					esac
					for _list in "${_vars_list[@]}"; do
						_var_call=$(printf "$_list"| cut -d',' -f1)
						_msg_call=$(printf "$_list"| cut -d',' -f2)
						_var_num=$(printf "$_list"| cut -d',' -f3)
						_var_tab=$(printf "$_list"| cut -d',' -f4)
						_section_var=$(printf "${edit_win[@]}"| cut -d';' -f$_var_num)
						if [[ $_section_var == TRUE ]]; then
							case $_var_call in
#								'w_config') _secondary_list='' ;;
								'w_install_tricks') _secondary_list=( 'w_tricks_list' );;
								'w_install_exe') _secondary_list=( 'w_exe_path' 'w_more_pkgs' 'w_install_zip' );;
								'use_winepath') _secondary_list=( 'wine_ver' );;
								'set_desktop_env') _secondary_list=( 'secondary_desktop' );;
								'mouse_set') _secondary_list=( 'mouse_dev' );;
								'auto_set') _secondary_list=( 'bck_xrandr' );;
							esac
							_var_exist=0
							if [ ${#_secondary_list[@]} -gt 0 ]; then
								for sub_var in ${_secondary_list[@]}; do
									eval _sub_var='$'$sub_var
									if [[ $_sub_var != '' ]]; then
										_var_exist=1
									fi
								done
							else
								_var_exist=1
							fi
							if [ $_var_exist -eq 1 ]; then
								sed -Eni "s/^($_var_call)=([0-9])$/\1=1/g;p" $config_file
								_msg_resume+=( "$nf$_msg_call section:$end$_var_tab\RESET\n" )
							else
								_msg_resume+=( "$nf$_msg_call section:$end$_var_tab\NOT SET IN CONF\n" )
							fi
						else
							_msg_resume+=( "$nf$_msg_call section:$end$_var_tab\NOT RESET\n" )
						fi
					done
				else
					_var_tab='\t\t'
					_msg_resume+=( "$nf$section_title section:$end$_var_tab\NOTHING TO DO (MISSING OR NOT SET)\n" )
				fi
			done
			## display a resume window of available reloadable vars before lauching process
			text="$bf\\Restarting $_edit_bottle Functions$end\\n
$vb\\The below config setups will be reset at next Winestarter start:$end
$vb(if they exist and are set in $_edit_bottle conf file)$end\\n
${_msg_resume[@]}"
			$zen_bin --width=500 --title="$w_title" --info --no-wrap \
				--window-icon=$img_wine_desk_ui --text="$text"
			exit 0 ;;
		3) _managed=$(printf "${edit_win[@]}"| cut -d';' -f3)
			unset _action_type _ui_options_0 _ui_options_1
			case $_managed in
				## copy/paste prefix and conf file indented by 1, or fill a new name.
				'Clone')
					w_text="$bf\\Clone$end"
					n=0
					_bottle_pre=$(printf "$_edit_bottle"| sed -En "s/^(.*)_[0-9]$/\1/g;p")
					if [[ $_edit_bottle =~ ^.*_[0-9] ]]; then
						n=$(printf "$_edit_bottle"| sed -En "s/^.*_([0-9])$/\1/g;p")
						_bottle_to=$(printf "$_edit_bottle"| sed -En "s/^(.*)_[0-9]$/\1/g;p")
					fi
					((n++))
					_ui_options_0+=("--field=$vb\\If no new name is privided, clone name is automaticaly idented by 1$end\\nEx: $_edit_bottle become $_bottle_pre\\_$n:LBL")
					_ui_options_1+=('')
					_ui_options_0+=("--field=$vf\\or change the clone name (optional)$end:")
					_ui_options_1+=('')
				;;
				## juste rename selected prefix.
				'Rename')
					w_text="$bf\\Rename$end"
					_ui_options_0+=("--field=$vb\\This will also rename all dedicated reg files inside the bottle$end:LBL")
					_ui_options_1+=('')
					_ui_options_0+=("--field=$nf\\New prefix name$end:")
					_ui_options_1+=("$_edit_bottle")
				;;
				## wipe prefix and conf file. Check box to preserve conf file.
				'Remove')
					w_text="$bf\\Remove$end"
					_ui_options_0+=("--field=$rb\\WARNING$end$nf: This will remove definitively $_edit_bottle config file and prefix.$end:LBL")
					_ui_options_1+=('')
					_ui_options_0+=("--field=$vb\\Are you really sure ?$end:LBL")
					_ui_options_1+=('')
				;;
			esac
			## UI interface
			select_win=$($yad_bin --width=520 --title "$w_title" --image=$img_bottle_mng --borders=15 \
				--window-icon=$img_desktop --center --separator=';' --form --item-separator="#" \
				--align=left --text "$w_text" --field="":LBL '' \
				"${_ui_options_0[@]}" "${_ui_options_1[@]}" )
			if [ $? = 0 ]; then
				_bottle_from=$_edit_bottle
				case $_managed in
					'Clone') [[ $_bottle_to ]]|| _bottle_to=$(printf "$select_win"| cut -d';' -f2)
						if ! [[ $_bottle_to ]]; then _bottle_to=$_edit_bottle'_'$n; fi
						_action_type+=(
						"cp -f $config_file $HOME/.winestarter/configs/$_bottle_to.conf"
						"cp -Rf -T $HOME/.$_bottle_from $HOME/.$_bottle_to"
						"mv -f -T $HOME/.$_bottle_to/$_bottle_from.reg $HOME/.$_bottle_to/$_bottle_to.reg"
						"sed -ni s/^bottle_prefix=.*$/bottle_prefix=\".$_bottle_to\"/g;p $HOME/.winestarter/configs/$_bottle_to.conf"
						);;
					'Rename') _bottle_to=$(printf "$select_win"| cut -d';' -f3)
						_action_type+=(
						"mv -f $config_file $HOME/.winestarter/configs/$_bottle_to.conf"
						"mv -f -T $HOME/.$_bottle_from $HOME/.$_bottle_to"
						"mv -f -T $HOME/.$_bottle_to/$_bottle_from.reg $HOME/.$_bottle_to/$_bottle_to.reg"
						"sed -ni s/^bottle_prefix=.*$/bottle_prefix=\".$_bottle_to\"/g;p $HOME/.winestarter/configs/$_bottle_to.conf"
						);;
					'Remove') _action_type+=("rm -Rf $config_file $HOME/.$_bottle_from");;
				esac
				for lets_work in "${_action_type[@]}"; do
					${lets_work}
				done
				bash $bash_opt $base_script; exit 0
			else
				bash $bash_opt $base_script; exit 0
			fi
		;;		
	esac
	if [[ $cmd_type =~ 0|1 ]]; then
		if [[ -e $HOME/.winestarter/configs/$_edit_bottle.conf ]]; then
			from_config=1
			export from_config=$from_config config_file=$config_file
			## launch bash command.
			bash $bash_opt "$bash_cmd"; exit 0
		else
			exit 0
		fi
	fi
}
. $HOME/.config/user-dirs.dirs
## Script debug options
#bash_opt='-x -c'
#code_tag=1
bash_opt='-c'
code_tag=0
## check internet connection.
line=$(nc -z 8.8.8.8 53)
export line=$?
## Main button commands
## commande type are :
## cmd_type = 0 > conf file edition.
## cmd_type = 1 > desktop file management.
## cmd_type = 2 > restart features.
## cmd_type = 3 > manage bottle's conf file.
main_cmd_0="bash $bash_opt \"colors; icons_set; b_set=1; code=0; from_config=0; main_code\""
main_cmd_1="bash $bash_opt \"colors; icons_set; b_set=0; from_config=1; cmd_type=0; edit_bottle\""
main_cmd_2="bash $bash_opt \"colors; icons_set; from_config=1; cmd_type=1; edit_bottle\""
main_cmd_3="bash $bash_opt \"colors; icons_set; change_fonts_colors\""
main_cmd_4="bash $bash_opt \"colors; icons_set; from_config=1; cmd_type=2; edit_bottle\""
main_cmd_5="bash $bash_opt \"colors; icons_set; from_config=1; cmd_type=3; edit_bottle\""

the_big_button="$HOME/.winestarter/png/defaults/winestarter_128.png"

main_text3="$vb\\Create$end"
main_text4="$vb\\Modify$end"

list_bottles
#messages; main_code
main_text0="$bf\\Stay simple with your Wine bottles$end$vb\\n\
\"Don't be a clic machine !\"$end\\n\\n\
$vb\\What do you want to do?$end\\n$vn(Hover buttons show tooltips)$end"

export -f colors icons_set
export -f main_code edit_bottle edit_desktop list_bottles change_fonts_colors edit_reg_bin edit_regfile edit_wine_options
export w_title="winestarter configurator" base_script="$0" bash_opt="$bash_opt" code_tag=$code_tag
control_last

$yad_bin --width=520 --title "Winestarter configurator"  --window-icon=$img_wine_desk_ui --no-buttons \
--form --text="$main_text0" --image=$the_big_button  --borders=15 \
--field="":LBL '' \
--field="$main_text3":LBL '' \
--field="$vb New Wine prefix $end"!$img_wine_add!"Create and config a fresh new Wine prefix":FBTN "$main_cmd_0" \
--field="$main_text4":LBL '' \
--field="$vb Edit a Wine bottle$end"!$img_wine_mod!"Add or change features, options, etc in an existing Wine bottle":FBTN "$main_cmd_1" \
--field="$vb Manage Wine bottles$end"!$img_wine_mng!"Remove,rename, clone an existing Wine bottle":FBTN "$main_cmd_5" \
--field="$vb Edit or create a Desktop file$end"!$img_wine_desk_bt!"Create a new or modify an existing Wine bottle Desktop file":FBTN "$main_cmd_2" \
--field="$vb Change fonts colors$end"!$img_wine_colors!"If you occur issues with default fonts colors, you can change them here":FBTN "$main_cmd_3" \
--field="$vb Restart and quick functions setup$end"!$img_wine_restart!"You can here restart or quick setup some functions at next Winestarter launch, ex: winecfg":FBTN "$main_cmd_4"

exit 0
